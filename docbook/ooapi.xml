<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="ru" xml:id="ooapi">
    <info>
        <title>Firebird interfaces</title>
    </info>
    <para>Объектно-ориентированный API Firebird (далее OO API) базируется на использовании
        интерфейсов. Эти интерфейсы, хотя и рассматриваются с точки зрения сравнения с
        OLE2-интерфейсами (некоторые из них имеют методы <methodname>addRef()</methodname> и
            <methodname>release()</methodname>), являются нестандартными и имеют функции,
        отсутствующие в других широко используемых типах интерфейсов. Прежде всего, интерфейсы
        Firebird <emphasis role="bold">не зависят от языка</emphasis> — это означает, что для их
        определения/использования им не нужно использовать конструкции, специфичные для языка, такие
        как класс в C++, интерфейс может быть определен с использованием любого языка, имеющего
        понятие массива и указателя на процедуру/функцию. Кроме того, интерфейсы <emphasis
            role="bold">версионны</emphasis> — то есть мы поддерживаем разные версии одного и того
        же интерфейса. Бинарная компоновка интерфейсов, предназначенная для поддержки этих функций
        очень эффективна (нет необходимости в дополнительных виртуальных вызовах таких как,
        например, в OLE2/COM с QueryInterface), но это не удобно для непосредственного использования
        в большинстве языков. Поэтому для упрощения использования API лучше использовать
        языково-ориентированные обертки для разных языков. В настоящее время у нас есть обертки для
        C++ и Pascal, скоро появится Java. Для конечного пользователя вызовы POV из C++ и Pascal нет
        никакой разницы, хотя в Pascal отсутствуют некоторые дополнительные языковые функции,
        присутствующие в C++ (например, возможность отключить автоматическую проверку статуса после
        вызовов API).</para>
    <para>Обычно API базы данных используется для доступа к данным, хранящимся в базе данных.
        Firebird OO API, безусловно, выполняет эту задачу, кроме того оно поддерживает создание
        собственных плагинов — модулей, которые позволяют расширить возможности Firebird в
        соответствии с вашими потребностями. Поэтому этот документ содержит две большие части —
        доступ к базам данных и написание плагинов. Некоторые интерфейсы (например, вектор
        состояния) используются в обеих частях API, они будут обсуждаться в части доступа к данным,
        позже при обсуждении плагинов мы будем свободно ссылаться на них. Поэтому, даже если вы
        планируете написать какой-то плагин, лучше начать с чтения первой части этого документа.
        Кроме того, многим плагинам необходимо обращаться к самим базам данных, и для этого
        необходим API доступа к данным.</para>
    <para>Пакет установки Firebird содержит ряд живых примеров использования OO API — они находятся
        в каталогах <filename>examples/interfaces</filename> (доступ к базе данных) и
            <filename>examples/dbcrypt</filename> (плагин, выполняющий фиктивное шифрование базы
        данных). Предполагается, что читатель знаком с ISC API, используемым в Firebird, со времён
        Interbase.</para>
    <para>Данный документ не претендует на полноту документации Firebird 3 — он просто описывает
        новый объектно-ориентированный API, и читатель должен быть знаком с основными концепциями
        Firebird, кроме того очень приветствуются знания о ISC API. Например, при описании работы со
        службами нет объяснения, что такое служба и для чего она необходима, только описание того,
        как получить интерфейс <link linkend="fbapi-interfaces-iservice">IService</link> и как его
        использовать. Кроме того, обратите внимание на то, что примеры кода не используют множество
        мощных возможностей C++. Не используются указатели с подсчетом ссылок, не используются
        другие хранители RAII, не используются шаблоны (кроме одного в публичных заголовках
        firebird) и т. д. Основная цель — сделать этот текст применимым не только для программистов
        C++, потому что наш API ориентирован на поддержку не только C++, но для других, более
        простых языков тоже.</para>
    <section xml:id="fbapi-dbaccess">
        <title>Доступ к базам данных</title>
        <section xml:id="fbapi-dbaccess-connect">
            <title>Создание базы данных и соединение с существующей базой данных</title>
            <para>Прежде всего нам нужно получить доступ к интерфейсу <link
                    linkend="fbapi-interfaces-imaster">IMaster</link>.
                    <interfacename>IMaster</interfacename> — это основной интерфейс Firebird,
                необходимый для доступа ко всем остальным интерфейсам. Поэтому существует особый
                способ доступа к нему — единственное, что нужно это использование простой функции OO
                API, называемой <function>fb_get_master_interface()</function>. Эта функция не имеет
                параметров и всегда успешна. Существует один и только один экземпляр
                    <interfacename>IMaster</interfacename> для каждой клиентской библиотеки
                Firebird, поэтому не нужно заботиться об освобождении памяти, используемой
                мастер-интерфейсом. Самый простой способ получить к нему доступ из вашей программы —
                иметь соответствующую глобальную или статическую переменную:
                <programlisting language="cpp">
static IMaster* master = fb_get_master_interface();    
            </programlisting>
            </para>
            <para>Для многих методов, используемых в API Firebird, первым параметром является
                интерфейс <link linkend="fbapi-interfaces-istatus">IStatus</link>. Это логичная
                замена ISC_STATUS_ARRAY, но работает отдельно с ошибками и предупреждениями (не
                смешивая их в одном массиве), может содержать неограниченное количество ошибок
                внутри и (это важно, если вы планируете реализовать
                    <interfacename>IStatus</interfacename> самостоятельно) всегда сохраняет строки,
                на которые он ссылается внутри интерфейса. Обычно для вызова других методов
                требуется хотя бы один экземпляр <interfacename>IStatus</interfacename>. Вы можете
                получить его из <interfacename>IMaster</interfacename>: <programlisting language="cpp">
<![CDATA[                      
IStatus* st = master->getStatus();  
]]>
            </programlisting>
            </para>
            <para>Если по какой-либо причине метод <methodname>getStatus()</methodname> не работает
                (OOM для примера), то он возвращает NULL — в этом случае очевидно, что мы не можем
                использовать общий метод для сообщений об ошибке, основанный на
                    <interfacename>IStatus</interfacename>.</para>
            <para>Теперь мы рассмотрим первый интерфейс, напрямую связанный с вызовами базы данных.
                Это <link linkend="fbapi-interfaces-iprovider">IProvider</link>-интерфейс,
                называемый таким образом, потому что именно этот интерфейс должен быть реализован
                любым поставщиком в Firebird. В клиентской библиотеке Firebird есть собственная
                реализация <interfacename>IProvider</interfacename>, которая должна использоваться
                для запуска любой активности базы данных. Чтобы получить его, мы вызываем метод
                    <interfacename>IMaster</interfacename>: <programlisting language="cpp">
<![CDATA[                    
IProvider* prov = master->getDispatcher(); 
]]>
            </programlisting>
            </para>
            <para>При подключении к существующей базе данных или создании новой часто требуется
                передать множество дополнительных параметров (логин/пароль, размер страницы для
                новой базы данных и т.д.) вызову API. Наличие отдельных параметров на уровне языка
                мало реально — нам придётся слишком часто менять вызов при добавлении новых
                параметров, и их число будет слишком большим, независимо от того, что многие из них
                обычно можно пропускать. Поэтому для передачи дополнительных параметров используется
                специальная структура данных в памяти, называемая блок параметров базы данных
                (database parameters block или DPB). Её формат чётко определён, и это даёт
                возможность построить DPB байт за байтом. Однако гораздо проще использовать
                специальный интерфейс <link linkend="fbapi-interfaces-ixpbbuilder"
                    >IXpbBuilder</link>, который упрощает создание различных блоков параметров.
                Чтобы получить экземпляр <interfacename>IXpbBuilder</interfacename>, необходимо
                знать об ещё одном универсальном интерфейсе Firebird API — <link
                    linkend="fbapi-interfaces-iutil">IUtil</link>. Это своего рода контейнер для
                вызовов, которые плохо подходят для размещения в других местах. Итак мы делаем
                следующее <programlisting language="cpp">
<![CDATA[
IUtil* utl = master->getUtilInterface();
IXpbBuilder* dpb = utl->getXpbBuilder(&status, IXpbBuilder::DPB, NULL, 0); 
]]>
            </programlisting>
            </para>
            <para>Этот код создает пустой конструктор блоков параметров типа DPB. Теперь добавление
                необходимого параметра в него тривиально: <programlisting language="cpp">
<![CDATA[
dpb->insertInt(&status, isc_dpb_page_size, 4 * 1024);
]]>
            </programlisting>
            </para>
            <para>будет создавать базу данных с размером страницы 4 Кб и значениями <programlisting language="cpp">
<![CDATA[
dpb->insertString(&status, isc_dpb_user_name, "sysdba");
dpb->insertString(&status, isc_dpb_password, "masterkey");
]]>
            </programlisting>
            </para>
            <para>смысл которых понятен. </para>
            <para><emphasis role="bold">Следующее приведено для C++</emphasis>: мы почти готовы
                вызвать метода <methodname>createDatabase()</methodname> экземпляра
                    <interfacename>IProvider</interfacename>, но перед этим необходимо сказать
                несколько слов о концепции Status Wrapper (обёртка над статусом). Status Wrapper не
                является интерфейсом, это очень тонкая обёртка над интерфейсом
                    <interfacename>IStatus</interfacename>. Она позволяет надстраивать поведение С++
                API (изменяет способ обработки ошибок, возвращаемых в интерфейсе
                    <interfacename>IStatus</interfacename>). Первое время мы рекомендуем
                использовать <classname>ThrowStatusWrapper</classname>, который вызывает исключение
                C++ каждый раз, когда в <interfacename>IStatus</interfacename> возвращается ошибка. <programlisting language="cpp">
<![CDATA[
ThrowStatusWrapper status(st);
]]>
            </programlisting>
            </para>
            <para>Теперь мы можем создать новую пустую базу данных: <programlisting language="cpp">
<![CDATA[
IAttachment* att = prov->createDatabase(&status, "fbtests.fdb", 
    dpb->getBufferLength(&status), dpb->getBuffer(&status));
printf("Database fbtests.fdb created\n");
]]>
            </programlisting>
            </para>
            <para>Обратите внимание, мы не проверяем статус после вызова
                    <methodname>createDatabase()</methodname>, потому что в случае ошибки будет
                возникать исключение C++ или Pascal (поэтому в вашей программе очень полезно иметь
                try/catch/except синтаксис). Мы также используем две новые функции из
                    <interfacename>IXpbBuilder</interfacename> —
                    <methodname>getBufferLength()</methodname> и
                    <methodname>getBuffer()</methodname>, которые извлекают данные из интерфейса в
                формате DPB. Как видите, нет необходимости явно проверять статус функций,
                возвращаемый промежуточными результатами.</para>
            <para>Отсоединение от только что созданной базы данных тривиально: <programlisting language="cpp">
<![CDATA[
att->detach(&status);
]]>
            </programlisting>
            </para>
            <para>Теперь осталось окружить все операторы блоком try и написать обработчик в блоке
                catch. При использовании <classname>ThrowStatusWrapper</classname>, вы всегда должны
                обрабатывать (catch) исключение класса <classname>FbException</classname>,
                определённого в C++ API, в Pascal вы также должны работать с классом
                    <classname>FbException</classname>. Блок обработки исключений в простейшем
                случае выглядит так: <programlisting language="cpp">
<![CDATA[
catch (const FbException& error)
{
    char buf[256];
    utl->formatStatus(buf, sizeof(buf), error.getStatus());
    fprintf(stderr, "%s\n", buf);
}
]]>
            </programlisting>
            </para>
            <para>Обратите внимание, здесь мы используем ещё одну функцию из <link
                    linkend="fbapi-interfaces-iutil">IUtil</link> —
                    <methodname>formatStatus()</methodname>. Она возвращает буфер с текстом,
                описывающим ошибку (предупреждение), сохранённую в параметре
                    <interfacename>IStatus</interfacename>.</para>
            <para>Чтобы подключиться к существующей базе данных используйте метод
                    <methodname>attachDatabase()</methodname> интерфейса
                    <interfacename>IProvider</interfacename> вместо
                    <methodname>createDatabase()</methodname>. Все параметры одинаковы для обоих
                методов. <programlisting language="cpp">
<![CDATA[
att = prov->attachDatabase(&status, "fbtests.fdb", 0, NULL);
]]>
            </programlisting>
            </para>
            <para>Данный пример не использует никаких дополнительных параметров DPB. Учтите, что без
                логина/пароля любое удалённое подключение будет неудачно, если не настроена
                доверительная аутентификация. Конечно информация о пользователе может быть
                предоставлена окружением (в переменных ISC_USER и ISC_PASSWORD), так же как это было
                раньше.</para>
            <para>Папка <filename>examples</filename> содержит завершённые примеры, в том числе и
                примеры создания базы данных — <filename>01.create.cpp</filename> и
                    <filename>01.create.pas</filename>. При чтении данного документа, полезно
                построить (build) примеры и попытаться запустить их.</para>
        </section>
        <section xml:id="fbapi-dbaccess-trans">
            <title>Работа с транзакциями</title>
            <para>Только создание пустых баз данных определенно недостаточно для работы с РСУБД. Мы
                хотим иметь возможность создавать в базе данных различные объекты (например, таблицы
                и т. д.) и вставлять данные в эти таблицы. В Firebird любая операция с базой данных
                выполняется под управлением транзакций. Поэтому прежде всего мы должны научиться
                стартовать транзакцию. Здесь мы не обсуждаем распределенные транзакции
                (поддерживаемые интерфейсом <link linkend="fbapi-interfaces-idtc">IDtc</link>),
                чтобы избежать ненужных для большинства пользователей сложностей. Запуск не
                распределенной транзакции очень прост и выполняется через интерфейс подключения: <programlisting language="cpp">
<![CDATA[
ITransaction* tra = att->startTransaction(&status, 0, NULL);
]]>
            </programlisting>
            </para>
            <para>В этом примере используются параметры транзакции по умолчанию — TPB не передается
                методу <methodname>startTransaction()</methodname>. Если вам нужна транзакция с
                параметрами отличными от параметров по умолчанию, вы можете создать соответствующий
                    <link linkend="fbapi-interfaces-ixpbbuilder">IXpbBuilder</link> и добавить к
                нему необходимые элементы: <programlisting language="cpp">
<![CDATA[
IXpbBuilder* tpb = utl->getXpbBuilder(&status, IXpbBuilder::TPB, NULL, 0);
tpb->insertTag(&status, isc_tpb_read_committed);
]]>
            </programlisting>
            </para>
            <para>и передать готовый TPB в <methodname>startTransaction()</methodname>: <programlisting language="cpp">
<![CDATA[
ITransaction* tra = att->startTransaction(&status, tpb->getBufferLength(&status), 
    tpb->getBuffer(&status));
]]>
</programlisting>
            </para>
            <para>Интерфейс транзакции используется как параметр во множестве других вызовов API, но
                сам он не выполняет никаких действий, кроме фиксации/отката (commit/rollback)
                транзакции, может быть сохранением контекста транзакции (retaining): <programlisting language="cpp">
<![CDATA[
tra->commit(&status);
]]>
</programlisting>
            </para>
            <para>Вы можете посмотреть, как начинать и подтверждать транзакцию в примерах
                    <filename>01.create.cpp</filename> и <filename>01.create.pas</filename>.</para>
        </section>
        <section xml:id="fbapi-dbaccess-execsql">
            <title>Выполнение оператора SQL без входных параметров и возвращаемых строк</title>
            <para>После старта транзакции мы готовы выполнять наши первые SQL операторы.
                Используемый для этого метод <methodname>execute()</methodname> в <link
                    linkend="fbapi-interfaces-iattachment">IAttachment</link> является довольно
                универсальным, и может также использоваться для выполнения операторов SQL с входными
                и выходными параметрами (что типично для инструкции EXECUTE PROCEDURE), но сейчас мы
                будем использовать наиболее простую его форму. Могут быть выполнены как DDL, так и
                DML операторы: <programlisting language="cpp">
<![CDATA[
att->execute(&status, tra, 0, "create table dates_table (d1 date)", 
    SQL_DIALECT_V6, NULL, NULL, NULL, NULL);
tra->commitRetaining(&status);
att->execute(&status, tra, 0, "insert into dates_table values (CURRENT_DATE)", 
    SQL_DIALECT_V6, NULL, NULL, NULL, NULL);
]]>
</programlisting>
            </para>
            <para>Как вы видите, интерфейс транзакции является обязательным параметром для метода
                    <methodname>execute()</methodname> (должен быть NULL, только если вы выполняете
                инструкцию START TRANSACTION). Следующим параметром следует длина SQL оператора
                (может быть равна нулю, в этом случае используются правила C для определения длины
                строки), потом текст оператора и диалект SQL, который должен использоваться для
                него. Далее следует несколько NULL которые подставляются для описания метаданных, и
                буферов входных параметров и выходных данных. Полное описание этого метода
                представлено в интерфейсе <link linkend="fbapi-interfaces-iattachment"
                    >IAttachment</link>. </para>
        </section>
        <section xml:id="fbapi-dbaccess-statement">
            <title>Выполнение SQL операторов с входными параметрами</title>
            <para>Существует два способа выполнения оператора с входными параметрами. Выбор
                правильного метода зависит от того, нужно ли вам выполнять его более одного раза, и
                знаете ли вы заранее формат параметров. Когда этот формат известен, и оператор нужно
                запускать только один раз, тогда вы можете воспользоваться одиночным вызовом
                    <methodname>IAttachment::execute()</methodname>. В противном случае сначала
                необходимо подготовить SQL-запрос, после чего его можно выполнять многократно с
                различными параметрами.</para>
            <para>Чтобы подготовить SQL оператор для выполнения, используйте метод
                    <methodname>prepare()</methodname> интерфейса <link
                    linkend="fbapi-interfaces-iattachment">IAttachment</link>: <programlisting language="cpp">
<![CDATA[
IStatement* stmt = att->prepare(&status, tra, 0, 
    "UPDATE department SET budget = ? * budget + budget WHERE dept_no = ?",
    SQL_DIALECT_V6, IStatement::PREPARE_PREFETCH_METADATA);
]]>
</programlisting>
            </para>
            <para>Если вы не собираетесь использовать описание параметров из Firebird (т.е. вы
                можете предоставить эту информацию самостоятельно), используйте
                    <code>IStatement::PREPARE_PREFETCH_NONE</code> вместо
                    <code>IStatement::PREPARE_PREFETCH_METADATA</code> — это немного снизит
                клиент/серверный трафик и сохранит ресурсы.</para>
            <para>В ISC API используется структура XSQLDA для описания формата параметров оператора.
                Новый API не использует XSQLDA — вместо этого используется интерфейс <link
                    linkend="fbapi-interfaces-imessagemetadata">IMessageMetadata</link>. Набор
                входных параметров (а также запись, взятая из курсора) описывается в Firebird API
                таким же образом, далее называемый сообщением.
                    <interfacename>IMessageMetadata</interfacename> передаётся в качестве параметра
                в методы обмена сообщениями между программой и движком базы данных. Существует много
                способов получить экземпляр <interfacename>IMessageMetadata</interfacename>, вот
                некоторые из них:<itemizedlist>
                    <listitem>
                        <para>получить из <link linkend="fbapi-interfaces-istatement"
                                >IStatement</link>;</para>
                    </listitem>
                    <listitem>
                        <para>построить используя <link linkend="fbapi-interfaces-imetadatabuilder"
                                >IMetadataBuilder</link> интерфейс;</para>
                    </listitem>
                    <listitem>
                        <para>иметь собственную реализацию этого интерфейса.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Получить метаданные из подготовленного запроса очень просто — метод
                    <methodname>getInputMetadata()</methodname> возвращает интерфейс, описывающий
                входное сообщение (т.е. параметры оператора), интерфейс, возвращаемый
                    <methodname>getOutputMetadata()</methodname>, описывает выходное сообщение (т.е.
                строку выбранных данных или значения, возвращаемые процедурой). В нашем случае мы
                можем сделать так: <programlisting language="cpp">
<![CDATA[
IMessageMetadata* meta = stmt->getInputMetadata(&status);
]]>
</programlisting>
            </para>
            <para>Или мы можем построить сообщение метаданных самостоятельно. Для этого прежде всего
                нам необходимо получить интерфейс построителя: <programlisting language="cpp">
<![CDATA[
IMetadataBuilder* builder = master->getMetadataBuilder(&status, 2);
]]>
</programlisting>
            </para>
            <para>Второй параметр — это ожидаемое количество полей в сообщении, его можно изменить
                позже, т.е. он необходим только для оптимизации.</para>
            <para>Теперь необходимо задать индивидуальные характеристики полей в построителе.
                Минимально необходимыми являются типы полей и длина для строковых полей: <programlisting language="cpp">
<![CDATA[
builder->setType(&status, 0, SQL_DOUBLE + 1);

builder->setType(&status, 1, SQL_TEXT + 1);
builder->setLength(&status, 1, 3);
]]>
</programlisting>
            </para>
            <para>Новый API использует старые константы для типов SQL, наименьший бит, как и раньше,
                используется для обозначения возможности принимать null значение. В некоторых
                случаях имеет смысл установить подтип (для BLOB), набор символов (для текстовых
                полей) или масштаб (для числовых полей). Наконец, пришло время получить экземпляр
                    <interfacename>IMessageMetadata</interfacename>: <programlisting language="cpp">
<![CDATA[
IMessageMetadata* meta = builder->getMetadata(&status);
]]>
</programlisting>
            </para>
            <para>Здесь мы не обсуждаем собственную реализацию
                    <interfacename>IMessageMetadata</interfacename>. Если вам это интересно, то вы
                можете посмотреть пример <filename>05.user_metadata.cpp</filename>.</para>
            <para>Итак, мы получили экземпляр описания метаданных входных параметров. Но для работы
                с сообщением нам также необходим буфер. Размер буфера является одной из основных
                характеристик сообщений метаданных и возвращается методом
                    <methodname>getMessageLength()</methodname> из
                    <interfacename>IMessageMetadata</interfacename>: <programlisting language="cpp">
<![CDATA[
char* buffer = new char[meta->getMessageLength(&status)];
]]>
</programlisting>
            </para>
            <para>Чтобы иметь дело с отдельными значениями внутри буфера, смещение к ним должно быть
                принято в расчёт. IMessageMetadata знает о смещениях для всех значений в сообщении,
                используя его, мы можем создавать указатели на них: <programlisting language="cpp">
<![CDATA[
double* percent_inc = (double*) &buffer[meta->getOffset(&status, 0)];
char* dept_no = &buffer[meta->getOffset(&status, 1)];
]]>
</programlisting>
            </para>
            <para>Кроме того, не забывайте установить NULL флаги: <programlisting language="cpp">
<![CDATA[
short* flag = (short*)&buffer[meta->getNullOffset(&status, 0)];
*flag = 0;

flag = (short*) &buffer[meta->getNullOffset(&status, 1)];
*flag = 0;
]]>
</programlisting>
            </para>
            <para>После завершения манипуляций со смещениями, мы готовы получить значения
                параметров: <programlisting language="cpp">
                <![CDATA[
getInputValues(dept_no, percent_inc);
]]>
</programlisting>
            </para>
            <para>и выполнить подготовленный оператор: <programlisting language="cpp">
                <![CDATA[
stmt->execute(&status, tra, meta, buffer, NULL, NULL);
]]>
</programlisting>
            </para>
            <para>Два последних NULL в параметрах предназначены для выходных сообщений и обычно
                используются для оператора EXECUTE PROCEDURE.</para>
            <para>Если вам не нужно получать метаданные из оператора и вы планируете выполнить его
                только один раз, то вы можете выбрать более простой способ — используйте метод
                    <methodname>execute()</methodname> из интерфейса <link
                    linkend="fbapi-interfaces-iattachment">IAttachment</link>:<programlisting language="cpp">
                <![CDATA[
att->execute(&status, tra, 0, 
    "UPDATE department SET budget = ? * budget + budget WHERE dept_no = ?", 
    SQL_DIALECT_V6, meta, buffer, NULL, NULL);
]]>
</programlisting></para>
            <para>В этом случае вам вообще не нужно использовать <link
                    linkend="fbapi-interfaces-istatement">IStatement</link>.</para>
            <para>Пример того, как выполнить оператор UPDATE с параметрами, присутствует в
                    <filename>02.update.cpp</filename>, вы также увидите, как возбужденное
                исключение в триггере/процедуре может быть перехвачено в программе на C++.</para>
        </section>
        <section xml:id="fbapi-dbaccess-cursor">
            <title>Открытие курсора и извлечение данных из него</title>
            <para>Единственный способ получить строки данных, возвращаемых оператором SELECT в OO
                API — это использовать интерфейс <link linkend="fbapi-interfaces-iresultset"
                    >IResultSet</link>. Этот интерфейс возвращается методом
                    <methodname>openCursor()</methodname> как в
                    <interfacename>IAttachment</interfacename>, так и в
                    <interfacename>IStatement</interfacename>. <methodname>openCursor()</methodname>
                в большинстве аспектов похож на <methodname>execute()</methodname>, и решение каким
                образом открыть курсор (с использованием подготовленного оператора или
                непосредственно из интерфейса подключения) то же. В примерах
                    <filename>03.select.cpp</filename> и <filename>04.print_table.cpp</filename>
                используются оба способа. Обратите внимание на одно отличие метода
                    <methodname>openCursor()</methodname> по сравнению с
                    <methodname>execute()</methodname> — никто не передает буфер для выходного
                сообщения в <methodname>openCursor()</methodname>, он будет передан позже, когда
                данные будут извлечены из курсора. Это позволяет открывать курсор с неизвестным
                форматом выходного сообщения (NULL передается вместо выходных метаданных). В этом
                случае Firebird использует формат сообщения по умолчанию, который может быть
                запрошен через интерфейс <interfacename>IResultSet</interfacename>: <programlisting language="cpp">
                <![CDATA[
const char* sql = "select * from ..."; // some select statement

IResultSet* curs = att->openCursor(&status, tra, 0, sql, SQL_DIALECT_V6, 
    NULL, NULL, NULL, NULL, 0);

IMessageMetadata* meta = curs->getMetadata(&status);
]]>
</programlisting>
            </para>
            <para>Позже эти метаданные могут использоваться для выделения буфера для данных и
                разбора извлечённых строк. </para>
            <para>В качестве альтернативы можно сначала подготовить оператор, получить метаданные из
                подготовленного оператора и после этого открыть курсор. Это предпочтительный способ,
                если вы предполагаете, что курсор будет открыт более одного раза. <programlisting language="cpp">
                <![CDATA[
IStatement* stmt = att->prepare(&status, tra, 0, sql, SQL_DIALECT_V6, 
    IStatement::PREPARE_PREFETCH_METADATA);

IMessageMetadata* meta = stmt->getOutputMetadata(&status);

IResultSet* curs = stmt->openCursor(&status, tra, NULL, NULL, NULL, 0);
]]>
</programlisting>
            </para>
            <para>Мы получили (тем или иным способом) экземпляр описания метаданных выходных полей
                (строк в наборе данных). Для работы с сообщением нам также нужен буфер: <programlisting language="cpp">
                <![CDATA[
unsigned char* buffer = new unsigned char[meta->getMessageLength(&status)];
]]>
</programlisting>
            </para>
            <para>В <interfacename>IResultSet</interfacename> есть много различных методов выборки,
                но когда курсор открыт не с параметром SCROLL, то работает только
                    <methodname>fetchNext()</methodname>, то есть можно перемещаться по записям
                только вперед. В дополнение к ошибкам и предупреждениям в статусе метод
                    <methodname>fetchNext()</methodname> возвращает код завершения, который может
                иметь значения RESULT_OK (когда буфер заполняется значениями для следующей строки)
                или RESULT_NO_DATA (когда в курсоре больше строк не осталось). RESULT_NO_DATA не
                является состоянием ошибки, это нормальное состояние после завершения метода,
                которое сигнализирует, что данных в курсоре больше нет. Если используется оболочка
                статуса (Status Wrapper), то исключение не бросается в случае возврата ошибки. Может
                быть возвращено еще одно значение — RESULT_ERROR — оно означает отсутствие данных в
                буфере и ошибки в статусе векторе. Метод <methodname>fetchNext()</methodname> обычно
                вызывается в цикле: <programlisting language="cpp">
                <![CDATA[
while (curs->fetchNext(&status, buffer) == IStatus::RESULT_OK)
{
    // row processing
}
]]>
</programlisting>
            </para>
            <para>То, что происходит при обработке строк, зависит от ваших потребностей. Для
                получения доступа к определённому полю следует использовать смещение поля: <programlisting language="cpp">
                <![CDATA[
unsigned char* field_N_ptr = buffer + meta->getOffset(&status, n);
]]>
</programlisting>
            </para>
            <para>где n - номер поля в сообщении. Этот указатель должен быть присвоен
                соответствующему типу, в зависимости от типа поля. Например, для поля VARCHAR,
                следует использовать приведение к структуре vary: <programlisting language="cpp">
                <![CDATA[
vary* v_ptr = (vary*) (buffer + meta->getOffset(&status, n));
]]>
</programlisting>
            </para>
            <para>Теперь мы можем напечатать значение поля: <programlisting language="cpp">
                <![CDATA[
printf("field %s value is %*.*s\n", 
       meta->getField(&status, n), 
       v_ptr->vary_length, 
       v_ptr->vary_length, 
       v_ptr->vary_string);
]]>
</programlisting>
            </para>
            <para>Если вам нужна максимальная производительность, будет полезно кэшировать
                необходимые значения метаданных, как это сделано в наших примерах
                    <filename>03.select.cpp</filename> и
                <filename>04.print_table.cpp</filename>.</para>
        </section>
        <section xml:id="fbapi-dbaccess-fbmessage">
            <title>Использование макросов FB_MESSAGE для статических сообщений</title>
            <para>Работа с данными с использованием смещений довольно эффективна, но требует
                написания большого количества кода. В C ++ эту проблему можно решить с помощью
                шаблонов, но даже по сравнению с ними наиболее удобным способом работы с сообщением
                является представление его в родном (для заданного языка) форме — структуре в C/C
                ++, записи в Pascal и т. д. Конечно это работает только в том случае, если формат
                сообщения известен заранее. Для создания таких структур в C ++ в Firebird существует
                специальный макрос FB_MESSAGE.</para>
            <para>FB_MESSAGE имеет 3 аргумента: имя сообщения (структуры), тип обёртки статуса
                (status wrapper) и список полей. Использование первого и второго аргумента очевидно,
                список полей содержит пары <code>(<replaceable>field_type</replaceable>,
                        <replaceable>field_name</replaceable>)</code>, где
                    <replaceable>field_type</replaceable> является одним из следующих: <itemizedlist>
                    <listitem>
                        <para><code>FB_BIGINT</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_BLOB</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_BOOLEAN</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_CHAR(<replaceable>len</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_DATE</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_DOUBLE</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_FLOAT</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_INTEGER</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_INTL_CHAR(<replaceable>len</replaceable>,
                                    <replaceable>charSet</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_INTL_VARCHAR(<replaceable>len</replaceable>,
                                    <replaceable>charSet</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_SCALED_BIGINT(<replaceable>x</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_SCALED_INTEGER(<replaceable>x</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_SCALED_SMALLINT(<replaceable>x</replaceable>)</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_SMALLINT</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_TIME</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_TIMESTAMP</code></para>
                    </listitem>
                    <listitem>
                        <para><code>FB_VARCHAR(<replaceable>len</replaceable>)</code></para>
                    </listitem>
                </itemizedlist></para>
            <para>В сгенерированной препроцессором структуре типы integer и float сопоставляются с
                соответствующими типами C, типы date и time — с классами <link
                    linkend="fbapi-classes-fbdate">FbDate</link> и <link
                    linkend="fbapi-classes-fbtime">FbTime</link> (все упомянутые здесь классы
                находятся в пространстве имен Firebird), тип timestamp — с классом <link
                    linkend="fbapi-classes-fbtimestamp">FbTimestamp</link>, содержащим два публичных
                члена данных дату и время соответствующих классов, тип char — со структурой <link
                    linkend="fbapi-objects-fbchar">FbChar</link> и varchar — со структурой <link
                    linkend="fbapi-objects-fbchar">FbVarChar</link>. Для каждого поля препроцессор
                создаст два члена данных — <replaceable>name</replaceable> для значения
                поля/параметра и <replaceable>nameNull</replaceable> для индикатора NULL.
                Конструктор сообщений имеет 2 параметра — указатель на оболочку статуса (status
                wrapper) и главный интерфейс (master interface): <programlisting language="cpp">
                <![CDATA[
FB_MESSAGE(Output, ThrowStatusWrapper,
    (FB_SMALLINT, relationId)
    (FB_CHAR(31), relationName)
    (FB_VARCHAR(100), description)
) output(&status, master);
]]>
</programlisting>
            </para>
            <para>Для статических сообщений использование FB_MESSAGE является самым лучшим выбором,
                в то же время они легко могут быть переданы в методы
                    <methodname>execute</methodname>, <methodname>openCursor</methodname> и
                    <methodname>fetch</methodname>: <programlisting language="cpp">
                <![CDATA[
rs = att->openCursor(&status, tra, 0, sqlText,
      SQL_DIALECT_V6, NULL, NULL, output.getMetadata(), NULL, 0);
]]>
</programlisting>
            </para>
            <para>и используется для работы со значениями отдельных полей: <programlisting language="cpp">
                <![CDATA[
while (rs->fetchNext(&status, output.getData()) == IStatus::RESULT_OK)
{
  printf("%4d %31.31s %*.*s\n", output->relationId, output->relationName.str,
    output->descriptionNull ? 0 : output->description.length,
    output->descriptionNull ? 0 : output->description.length, 
    output->description.str);
}
]]>
</programlisting>
            </para>
            <para>Пример использования макроса FB_MESSAGE для работы с сообщениями приведен в
                примере <filename>06.fb_message.cpp</filename>.</para>
        </section>
        <section xml:id="fbapi-dbaccess-blob">
            <title>Работа с BLOB</title>
            <para>Для BLOBs Firebird хранит в буфере сообщения идентификатор BLOB — 8 байтовый
                объект, который должен быть выравнен по 4-байтной границе. Идентификатор имеет тип
                ISC_QUAD. Интерфейс <link linkend="fbapi-interfaces-iattachment">IAttachment</link>
                имеет 2 метода для работы с BLOB — <methodname>openBlob()</methodname> и
                    <methodname>createBlob()</methodname>, возвращающие интерфейс <link
                    linkend="fbapi-interfaces-iblob">IBlob</link> и имеющие одинаковый набор
                параметров, но выполняющие несколько разные действия:
                    <methodname>openBlob()</methodname> принимает BLOB идентификатор из сообщения и
                подготавливает BLOB для чтения, а <methodname>createBlob()</methodname> создает
                новый BLOB, помещает его идентификатор в сообщение и подготавливает BLOB для
                записи.</para>
            <para>Для работы с BLOBs прежде всего необходимо включить в сообщение их
                BLOB-идентификаторы. Если вы получите метаданные из поля движка Firebird
                соответствующего типа, то этот идентификатор уже будет присутствовать. В этом случае
                вы просто используете его смещение (при условии, что переменная blobFieldNumber
                содержит номер поля BLOB) (и соответствующее NULL смещение для проверки NULL или
                установки NULL флага) для получения указателя в буфере сообщений: <programlisting language="cpp">
                <![CDATA[
ISC_QUAD* blobPtr = 
  (ISC_QUAD*) &buffer[metadata->getOffset(&status, blobFieldNumber)];
ISC_SHORT* blobNullPtr = 
  (ISC_SHORT*) &buffer[metadata->getNullOffset(&status, blobFieldNumber)];
]]>
</programlisting>
            </para>
            <para>Если вы используете статические сообщениями макрос FB_MESSAGE, то поле BLOB будет
                объявлено как тип FB_BLOB: <programlisting language="cpp">
                <![CDATA[
FB_MESSAGE(Msg, ThrowStatusWrapper,
    (FB_BLOB, b)
) message(&status, master);

ISC_QUAD* blobPtr = &message->b;
ISC_SHORT* blobNullPtr = &message->bNull;
]]>
</programlisting>
            </para>
            <para>Для создания нового BLOB, вызовите метод <methodname>createBlob()</methodname>: <programlisting language="cpp">
                <![CDATA[
IBlob* blob = att->createBlob(status, tra, blobPtr, 0, NULL);
]]>
</programlisting>
            </para>
            <para>Последние два параметра требуются только в том случае, если вы хотите использовать
                blob-фильтры или blob-поток, которые не рассматриваются здесь. </para>
            <para>Теперь Blob интерфейс готов принять данные в BLOB. Используйте метод
                    <methodname>putSegment()</methodname> для отправки данных в движок: <programlisting language="cpp">
                <![CDATA[
void* segmentData;
unsigned segmentLength;
while (userFunctionProvidingBlobData(&segmentData, &segmentLength))
    blob->putSegment(&status, segmentLength, segmentData);
]]>
</programlisting>
            </para>
            <para>После отправки некоторых данных в BLOB не забудьте закрыть blob-интерфейс: <programlisting language="cpp">
                <![CDATA[
blob->close(&status);
]]>
</programlisting>
            </para>
            <para>Убедитесь, что null флаг не установлен (не требуется, если вы сбросили весь буфер
                сообщений перед созданием BLOB): <programlisting language="cpp">
                <![CDATA[
*blobNullPtr = 0;
]]>
</programlisting>
            </para>
            <para>и сообщение, содержащее BLOB, может использоваться в операторе вставки или
                обновления. После выполнения этого оператора новый BLOB будет сохранен в базе
                данных. </para>
            <para>Чтобы прочитать blob, необходимо получить его идентификатор в сообщении от
                двигателя firebird. Это можно сделать с помощью методов
                    <methodname>fetch()</methodname> или <methodname>execute()</methodname>. После
                этого используйте метод <methodname>openBlob()</methodname>: <programlisting language="cpp">
                <![CDATA[
IBlob* blob = att->openBlob(status, tra, blobPtr, 0, NULL);
]]>
</programlisting></para>
            <para>Blob интерфейс готов предоставить данные BLOB. Используйте метод
                    <methodname>getSegment()</methodname> для получения данных из движка: <programlisting language="cpp">
                <![CDATA[
char buffer[BUFSIZE];
unsigned actualLength;

for(;;)
{
  switch (blob->getSegment(&status, sizeof(buffer), buffer, &actualLength))
  {
    case IStatus::RESULT_OK:
      userFunctionAcceptingBlobData(buffer, actualLength, true);
      continue;

    case IStatus::RESULT_SEGMENT:
      userFunctionAcceptingBlobData(buffer, actualLength, false);
      continue;

    default:
      break;
  }
}
]]>
</programlisting></para>
            <para>Последний параметр в <function>userFunctionAcceptingBlobData()</function> — это
                флаг достижения конца сегмента — когда <methodname>getSegment()</methodname>
                возвращает код завершения RESULT_SEGMENT, о чём будет уведомлена функция (в
                последний параметр передан <literal>false</literal>), то есть этот сегмент прочитан
                не полностью, и продолжение ожидается при следующем вызове.</para>
            <para>Закончив работать с BLOB, не забудьте закрыть его: <programlisting language="cpp">
                <![CDATA[
blob->close(&status);
]]>
</programlisting>
            </para>
        </section>
        <section xml:id="fbapi-dbaccess-events">
            <title>Работа с событиями</title>
            <para>Интерфейс событий не был завершен в Firebird 3.0, мы ожидаем, что в следующей
                версии будет что-то более интересное. Минимальная существующая поддержка выглядит
                следующим образом: <link linkend="fbapi-interfaces-iattachment">IAttachment</link>
                содержит метод <methodname>queEvents()</methodname>, который выполняет почти те же
                функции, что и вызов <methodname>isc_que_events()</methodname>. Вместо пары
                параметров <code>FPTR_EVENT_CALLBACK ast</code> и <code>void* arg</code>,
                необходимых для вызова кода пользователя, когда в Firebird происходит событие,
                используется интерфейс обратного вызова
                    <interfacename>IEventCallback</interfacename>. Это традиционный подход, который
                помогает избежать небезопасных бросков из void* в пользовательской функции. Другое
                важное различие заключается в том, что вместо идентификатора события (вида
                обработчика) эта функция возвращает ссылку на интерфейс <link
                    linkend="fbapi-interfaces-ievents">IEvents</link>, имеющий метод
                    <methodname>cancel()</methodname>, используемый для остановки ожидании события.
                В отличие от идентификатора, который уничтожается автоматически при поступлении
                события, интерфейс не может быть уничтожен автоматически, если событие получено
                непосредственно перед вызовом метода <methodname>cancel()</methodname>, то это
                вызовет segfault из-за того, что интерфейс уже будет уничтожен. Поэтому после
                получения события интерфейс <link linkend="fbapi-interfaces-ievents">IEvents</link>
                должен быть явно освобождён. Это может быть сделано, например, прямо перед запросом
                события из очереди в следующий раз: <programlisting language="cpp">
                <![CDATA[
events->release();
events = NULL;

events = attachment->queEvents(&status, this, eveLen, eveBuffer);
]]>
</programlisting>
            </para>
            <para>Установка указателя интерфейса в NULL полезна в случае возникновения исключения в
                queEvents. В других аспектах обработка событий не изменилась по сравнению с ISC API.
                Для получения дополнительной информации используйте наш пример
                    <filename>08.events.cpp</filename>.</para>
        </section>
        <section xml:id="fbapi-dbaccess-services">
            <title>Использование сервисов</title>
            <para>Чтобы начать пользоваться сервисами (службами), прежде всего необходимо
                подключиться к менеджеру сервисов. Это делается с помощью метода
                    <methodname>attachServiceManager()</methodname> интерфейса <link
                    linkend="fbapi-interfaces-iprovider">IProvider</link>. Этот метод возвращает
                интерфейс <link linkend="fbapi-interfaces-iservice">IService</link>, который позже
                используется для связи с сервисом. Чтобы подготовить SPB для подключения к
                диспетчеру сервисов, вы можете использовать
                    <interfacename>IXpbBuilder</interfacename>: <programlisting language="cpp">
                <![CDATA[
IXpbBuilder* spb1 = utl->getXpbBuilder(&status, IXpbBuilder::SPB_ATTACH, NULL, 0);

spb1->insertString(&status, isc_spb_user_name, "sysdba");
spb1->insertString(&status, isc_spb_password, "masterkey");
]]>
</programlisting>
            </para>
            <para>и подключится: <programlisting language="cpp">
                <![CDATA[
IService* svc = prov->attachServiceManager(&status, "service_mgr", 
    spb1->getBufferLength(&status), spb1->getBuffer(&status));
]]>
</programlisting>
            </para>
            <para>Используя <interfacename>IService</interfacename>, вы можете выполнять как
                доступные для служб действия — запускать службы, так и запрашивать различную
                информацию о запущенных утилитах и сервере в целом. При запросе информации, есть
                одно ограничение — формат блока параметров, используемый методом
                    <methodname>query()</methodname>, в Firebird 3 не поддерживается
                    <interfacename>IXpbBuilder</interfacename>. Вероятно, поддержка будет добавлена
                в более поздних версиях, в Firebird 3 вам придется создавать и анализировать этот
                блок вручную. Формат этого блока повторяет старый формат (используемый в ISC API)
                один в один.</para>
            <para>Чтобы стартовать сервис, необходимо прежде всего создать соответствующий SPB: <programlisting language="cpp">
                <![CDATA[
IXpbBuilder* spb2 = utl->getXpbBuilder(&status, IXpbBuilder::SPB_START, NULL, 0);
]]>
</programlisting>
            </para>
            <para>и добавить к нему необходимые элементы. Например, для печати статистики шифрования
                для базы данных <filename>employee</filename> в SPB следует поместить следующее: <programlisting language="cpp">
                <![CDATA[
spb2->insertTag(&status, isc_action_svc_db_stats);
spb2->insertString(&status, isc_spb_dbname, "employee");
spb2->insertInt(&status, isc_spb_options, isc_spb_sts_encryption);
]]>
</programlisting></para>
            <para>После этого сервис можно запустить с использованием метода
                    <methodname>start()</methodname> интерфейса
                    <interfacename>IService</interfacename>: <programlisting language="cpp">
                <![CDATA[
svc->start(&status, spb2->getBufferLength(&status), spb2->getBuffer(&status));
]]>
</programlisting></para>
            <para>Многие запущенные службы (включая упомянутый здесь
                    <application>gstat</application>) во время выполнения возвращают текстовую
                информацию. Чтобы отобразить её, необходимо запросить эту информацию у запущенного
                сервиса построчно. Это делается с помощью вызова метода
                    <methodname>query()</methodname> интерфейса <link
                    linkend="fbapi-interfaces-iservice">IService</link> с соответствующими блоками
                параметров для приёма и отправки. Блок отправки может содержать различную
                вспомогательную информацию (например, тайм-аут запроса у службы) или информацию,
                которая должна быть передана в служебную программу <application>stdin</application>,
                или может быть пустым в простейшем случае. Блок приема должен содержать список
                тегов, которые вы хотите получать из службы. Для большинства утилит это единственный
                    <code>isc_info_svc_line</code>: <programlisting language="cpp">
                <![CDATA[
const unsigned char receiveItems1[] = {isc_info_svc_line};
]]>
</programlisting>
            </para>
            <para>Кроме того, для запроса этой информации для неё необходим буфер: <programlisting language="cpp">
                <![CDATA[
unsigned char results[1024];
]]>
</programlisting>
            </para>
            <para>После этих предварительных шагов мы готовы запросить информацию из сервиса в цикле
                (каждая строка возвращается в одном вызове <methodname>query()</methodname>): <programlisting language="cpp">
                <![CDATA[
do
{
    svc->query(&status, 0, NULL, 
               sizeof(receiveItems1), receiveItems1, 
               sizeof(results), results);
} while (printInfo(results, sizeof(results)));
]]>
</programlisting>
            </para>
            <para>В этом примере мы предполагаем, что функция <function>printInfo()</function>
                возвращает TRUE, пока сервис возвращает блок результатов, содержащий следующую
                выходную строку (то есть до конца потока данных из сервиса). Формат блока
                результатов варьируется от сервиса к сервису, а некоторые сервисы, такие как
                    <application>gsec</application>, создают исторические форматы, которые не
                являются тривиальными для синтаксического анализа, но это выходит за рамки данной
                главы. Минимальный рабочий пример <function>printInfo()</function> присутствует в
                примере <filename>09.service.cpp</filename>.</para>
            <para>Тот же метод запроса используется для извлечения информации о сервере, но в этом
                случае функция запроса не вызывается в цикле, т. е. буфер должен быть достаточно
                большим, чтобы сразу вместить всю информацию. Это не слишком сложно, так как обычно
                такие вызовы не возвращают много данных. Как и в предыдущем случае, необходимо
                начать с того, чтобы разместить в блоке приема необходимые элементы — в нашем
                примере это <code>isc_info_svc_server_version</code>: <programlisting language="cpp">
                <![CDATA[
const unsigned char receiveItems2[] = {isc_info_svc_server_version};
]]>
</programlisting>
            </para>
            <para>Существующий буфер результатов из предыдущего вызова может быть использован
                повторно. В данном случае цикл не требуется: <programlisting language="cpp">
                <![CDATA[
svc->query(&status, 0, NULL, 
           sizeof(receiveItems2), receiveItems2, 
           sizeof(results), results);

printInfo(results, sizeof(results));
]]>
</programlisting>
            </para>
            <para>После завершения сервисных задач не забудьте отключить сервис: <programlisting language="cpp">
                <![CDATA[
svc->detach(&status);
]]>
</programlisting>
            </para>
        </section>
    </section>
    <section xml:id="fbapi-plugins">
        <title>Написание плагинов</title>
        <para>Чтобы написать плагин, нужно реализовать некоторые интерфейсы и поместить вашу
            реализацию в динамическую библиотеку (<filename>.dll</filename> в Windows или
                <filename>.so</filename> в Linux), которую называют модулем плагина или просто
            модулем. В большинстве случаев одиночный плагин размещается в динамической библиотеке,
            но не обязательно. Один из этих интерфейсов — <link
                linkend="fbapi-interfaces-ipluginmodule">IPluginModule</link> — является модульным
            (как более или менее ясно из его имени), другие отвечают за плагин. Также каждый модуль
            плагина должен содержать специальную экспортированную точку входа
                <function>firebird_plugin()</function>, имя которой указано в файле
                <filename>include/firebird/Interfaces.h</filename> как FB_PLUGIN_ENTRY_POINT.</para>
        <para>В предыдущей части мы в основном описывали, как использовать существующие интерфейсы,
            здесь основное внимание будет уделено самостоятельной реализации интерфейсов.
            Разумеется, для этого можно и нужно использовать уже существующие интерфейсы, общие для
            доступа к базам данных Firebird (уже описанные) и некоторые дополнительные интерфейсы,
            специально предназначенные для плагинов.</para>
        <para>Далее активно используется пример плагина шифрования базы данных
                <filename>examples/dbcrypt/DbCrypt.cpp</filename>. Будет хорошей идеей собрать этот
            пример самостоятельно и изучить его при чтении позже.</para>
        <section xml:id="fbapi-plugins-module">
            <title>Реализация модуля плагина</title>
            <para>Плагины активно взаимодействуют со специальным компонентом Firebird, называемым
                диспетчером плагинов. В частности, менеджер плагинов должен знать, какие модули
                плагина были загружены и должен быть уведомлен, если операционная система пытается
                выгрузить один из этих модулей без явной команды диспетчера плагина (это может
                произойти прежде всего при использовании встроенного сервера (embedded) — когда в
                программе вызывается <function>exit()</function> или основная библиотека Firebird
                    <filename>fbclient</filename> выгружается). Основная задача интерфейса
                    <interfacename>IPluginModule</interfacename> — это уведомление. Прежде всего,
                нужно решить — как определить, что модуль будет выгружен? Когда динамическая
                библиотека выгружается по какой-либо причине, выполняется множество зависимых от ОС
                действий, и некоторые из этих действий могут использоваться для обнаружения этого
                факта в программе. При написании плагинов, распространяемых вместе с firebird, мы
                всегда используем вызов деструктора глобальной переменной. Большой «плюс» этого
                метода заключается в том, что он независим от ОС (хотя что-то вроде функции
                    <function>exit()</function>, возможно, также успешно используется). Но
                использование деструктора позволяет легко сконцентрировать почти все, что связано с
                обнаружением выгрузки в одном классе, реализуя в то же время интерфейс <link
                    linkend="fbapi-interfaces-ipluginmodule">IPluginModule</link>.</para>
            <para>Минимальная реализация выглядит следующим образом: <programlisting language="cpp">
                <![CDATA[
class PluginModule : public IPluginModuleImpl<PluginModule, CheckStatusWrapper>
{

private:
  IPluginManager* pluginManager;

public:
  PluginModule()
    : pluginManager(NULL)
  { }


  ~PluginModule()
  {
    if (pluginManager)
    {
      pluginManager->unregisterModule(this);
      doClean();
    }
  }

  void registerMe(IPluginManager* m)
  {
    pluginManager = m;
    pluginManager->registerModule(this);
  }

  void doClean()
  {
    pluginManager = NULL;
  }

};
]]>
</programlisting>
            </para>
            <para>Единственным членом данных является интерфейс диспетчера плагинов <link
                    linkend="fbapi-interfaces-ipluginmanager">IPluginManager</link>. Он передается
                функции <methodname>registerModule()</methodname> и сохраняется в приватной
                переменной, в то же время модуль регистрируется в диспетчере плагинов методом
                    <methodname>callModule()</methodname> с собственным адресом в качестве
                единственного параметра. Переменная <varname>pluginManager</varname> не только
                сохраняет указатель на интерфейс, но одновременно служит в качестве флага, что
                модуль зарегистрирован. Когда вызывается деструктор зарегистрированного модуля, он
                уведомляет диспетчер плагинов о неожиданной выгрузке с помощью вызова
                    <methodname>unregisterModule()</methodname>, передающим указатель на себя. Когда
                диспетчер плагинов будет регулярно выгружать модуль, то в первую очередь вызов
                метода <methodname>doClean()</methodname> меняет состояние модуля на
                незарегистрированное, и это позволяет избежать вызова
                    <methodname>unregisterModule()</methodname>, когда ОС выполняет фактическую
                выгрузку.</para>
            <para>Реализовав интерфейс плагина <interfacename>IPluginModule</interfacename>, мы
                встретились с первым интерфейсом, необходимым для реализации плагинов —
                    <interfacename>IPluginManager</interfacename>. Он будет активно использоваться
                позже, остальные члены этого класса вряд ли потребуются вам после копирования в вашу
                программу. Просто не забудьте объявить глобальную переменную этого типа и вызвать
                функцию <methodname>registerMe()</methodname> из FB_PLUGIN_ENTRY_POINT.</para>
        </section>
        <section xml:id="fbapi-plugins-pluginbase">
            <title>Основной интерфейс любого плагина</title>
            <para>Приступим к реализации самого плагина. Тип основного интерфейса зависит от типа
                плагина (что очевидно), но все они основаны на общем интерфейсе
                    <interfacename>IPluginBase</interfacename> с подсчётом ссылок, который выполняет
                общие для всех плагинов (и очень простые) задачи. Каждый плагин имеет некоторый
                (тоже с подсчётом ссылок) объект, которому принадлежит этот плагин. Чтобы выполнять
                интеллектуальное управление жизненным циклом плагинов, любой плагин должен иметь
                возможность хранить информацию о владельце и сообщать её диспетчеру плагинов по
                запросу. Это означает, что каждый плагин должен реализовывать два тривиальных метода
                    <methodname>setOwner()</methodname> и <methodname>getOwner()</methodname>,
                содержащиеся в интерфейсе <interfacename>IPluginBase</interfacename>. Зависимые от
                типа плагина методы, безусловно, более интересны — они обсуждаются в части описания
                интерфейсов.</para>
            <para>Давайте рассмотрим типичную часть реализации любого плагина (здесь я специально
                использую несуществующий тип <classname>SomePlugin</classname>): <programlisting language="cpp">
                <![CDATA[
class MyPlugin : public ISomePluginImpl<MyPlugin, CheckStatusWrapper>
{
public:
  explicit MyPlugin(IPluginConfig* cnf) throw()
     : config(cnf), refCounter(0), owner(NULL)
  {
    config->addRef();
  }
  ...
]]>
</programlisting>
            </para>
            <para>Конструктор получает в качестве параметра интерфейс конфигурации плагина. Если вы
                собираетесь конфигурировать плагин каким-то образом, то рекомендуется сохранить этот
                интерфейс в вашем плагине и использовать его позже. Это позволит вам использовать
                общий стиль конфигурации Firebird, позволяя пользователям иметь привычную
                конфигурацию и свести к минимуму написание кода. Конечно, при сохранении какого-либо
                ссылочного интерфейса лучше не забывать добавлять ссылку на него. Также не забудьте
                установите счетчик ссылок в 0 и владельца плагина в NULL. </para>
            <para>
                <programlisting language="cpp">
                <![CDATA[
  ~MyPlugin()
  {
    config->release();
  }
]]>
</programlisting>
            </para>
            <para>Деструктор освобождает конфигурационный интерфейс. Обратите внимание: мы не меняем
                счетчик ссылок нашего владельца, потому что он принадлежит нам, а не мы принадлежим
                ему. <programlisting language="cpp">
                <![CDATA[
  // IRefCounted implementation
  int release()
  {
    if (--refCounter == 0)
    {
      delete this;
      return 0;
    }
    return 1;
  }


  void addRef()
  {
    ++refCounter;
  }
]]>
</programlisting>
            </para>
            <para>Абсолютно типичная реализация объекта с подсчётом ссылок. </para>
            <para>
                <programlisting language="cpp">
                <![CDATA[
  // IPluginBase implementation
  void setOwner(IReferenceCounted* o)
  {
    owner = o;
  }

  IReferenceCounted* getOwner()
  {
    return owner;
  }
]]>
</programlisting>
            </para>
            <para>Как и было обещано, реализация <interfacename>IPluginBase</interfacename>
                тривиальна. </para>
            <para>
                <programlisting language="cpp">
                <![CDATA[
  // ISomePlugin implementation
  // … here go various methods required for particular plugin type
private:
  IPluginConfig* config;
  FbSampleAtomic refCounter;
  IReferenceCounted* owner;
};
]]>
</programlisting>
            </para>
            <para>В этом примере формальная часть реализации основного интерфейса плагина завершена.
                После добавления специфичных для типа методов (и, возможно, написания кода, чтобы
                сделать их полезным), интерфейс готов.</para>
        </section>
        <section xml:id="fbapi-plugins-factory">
            <title>Фабрика плагинов</title>
            <para>Еще один интерфейс, необходимый для работы плагина — <link
                    linkend="fbapi-interfaces-ipluginfactory">IPluginFactory</link>. Фабрика создает
                экземпляры плагина и возвращает их в диспетчер плагинов. Фабрика обычно выглядит
                так: <programlisting language="cpp">
                <![CDATA[
class Factory : public IPluginFactoryImpl<Factory, CheckStatusWrapper>
{
public:
  IPluginBase* createPlugin(CheckStatusWrapper* status, 
                            IPluginConfig* factoryParameter)
  {
    MyPlugin* p = new MyPlugin(factoryParameter);
    p->addRef();
    return p;
  }
};
]]>
</programlisting>
            </para>
            <para>Здесь внимание следует уделить тому факту, что даже в случае, когда код в функции
                может генерировать исключения (оператор new может бросать в случае, когда память
                исчерпана), то не обязательно всегда вручную определять блок try/catch — реализация
                интерфейсов Firebird делает эту работу за вас, в реализации
                    <interfacename>IPluginFactory</interfacename> эта обработка происходит в шаблоне
                    <interfacename>IPluginFactoryImpl</interfacename>. Обратите внимание, что
                обертки статуса по умолчанию выполняют полноценную обработку только для
                    <classname>FbException</classname>. Но если вы работаете над каким-то крупным
                проектом, то определите свою собственную оболочку, в этом случае вы можете
                обрабатывать любой тип исключения C++ и передавать полезную информацию об этом из
                своего плагина.</para>
        </section>
        <section xml:id="fbapi-plugins-entrypoint">
            <title>Точка инициализации модуля плагина</title>
            <para>Когда диспетчер плагинов загружает модуль плагина, он вызывает процедуру
                инициализации модуля — единственную экспортируемую функцию плагина
                FB_PLUGIN_ENTRY_POINT. Для написания кода ей понадобятся две глобальные переменные —
                модуль плагина и фабрика плагинов. В нашем случае это: <programlisting language="cpp">
                <![CDATA[
PluginModule module;

Factory factory;
]]>
</programlisting>
            </para>
            <para>Если модуль содержит более одного плагина, вам понадобится фабрика для каждого
                плагина.</para>
            <para>Для FB_PLUGIN_ENTRY_POINT мы не должны забывать, что она должна быть
                экспортирована из модуля плагина, для этого требуется учет некоторых особенностей
                ОС. Мы делаем это, используя макрос FB_DLL_EXPORT, определенный в
                    <filename>examples/interfaces/ifaceExamples.h</filename>. Если вы уверены, что
                используете плагин только для некоторых конкретных ОС, то вы можете сделать это
                место немного проще. В минимальном случае функция должна регистрировать модуль и все
                фабрики в диспетчере плагинов: <programlisting language="cpp">
                <![CDATA[
extern "C" void FB_DLL_EXPORT FB_PLUGIN_ENTRY_POINT(IMaster* master)
{
  IPluginManager* pluginManager = master->getPluginManager();
  module.registerMe(pluginManager);
  pluginManager->registerPluginFactory(IPluginManager::TYPE_DB_CRYPT, 
                                       "DbCrypt_example", 
                                       &factory);
}
]]>
</programlisting>
            </para>
            <para>Прежде всего, мы вызываем недавно написанную нами функцию
                    <methodname>PluginModule::registerMe()</methodname>, которая сохраняет
                    <interfacename>IPluginManager</interfacename> для дальнейшего использования и
                регистрирует наш модуль плагина. Затем регистрируем фабрику (или фабрики если в
                одном модуле будет несколько плагинов). Мы должны передать правильный тип плагина
                (допустимые типы перечислены в интерфейсе
                    <interfacename>IPluginManager</interfacename>) и имя, под которым будет
                зарегистрирован плагин. В простейшем случае он должен совпадать с именем
                динамической библиотеки модуля плагина. Это правило поможет вам не настраивать
                плагин вручную в <filename>plugins.conf</filename>.</para>
            <para>Обратите внимание — в отличие от приложений плагины не должны использовать
                    <function>fb_get_master_interface()</function> для получения
                    <interfacename>IMaster</interfacename>. Вместо этого следует использовать
                экземпляр, переданный в FB_PLUGIN_ENTRY_POINT. Если вам нужен мастер-интерфейс в
                вашем плагине, позаботьтесь об его сохранении в этой функции.</para>
        </section>
    </section>
    <section xml:id="fbapi-interfaces">
        <title>Интерфейсы от A до Z</title>
        <para>В этом глоссарии мы не перечисляем интерфейсы, которые не используются активно
            (например, <interfacename>IRequest</interfacename>, необходимые в первую очередь для
            поддержки устаревших запросов API ISC). Та же ссылка может быть получена из некоторых
            методов (например, <methodname>compileRequest()</methodname> в
                <interfacename>IAttachment</interfacename>). Для интерфейсов/методов, имеющих прямой
            аналог в старом API, этот аналог будет указан.</para>
        <section xml:id="fbapi-interfaces-common">
            <title>Общие интерфейсы</title>
            <section xml:id="fbapi-interfaces-iattachment">
                <info>
                    <title>IAttachment</title>
                    <keywordset>
                        <keyword>IAttachment</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IAttachment</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IAttachment</interfacename> заменяет
                            <code>isc_db_handle</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getInfo</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getInfo(StatusType* status, 
             unsigned itemsLength, 
             const unsigned char* items, 
             unsigned bufferLength, 
             unsigned char* buffer)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_database_info()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>startTransaction</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* startTransaction(StatusType* status, 
                               unsigned tpbLength, 
                               const unsigned char* tpb)
]]>
</programlisting>
                            </para>
                            <para>частично заменяет <code>isc_start_multiple()</code>, использует
                                координатор, чтобы запустить более одной распределённой транзакции.
                                Позволяет объединить 2 транзакции в одну распределённую.</para>
                        </listitem>
                        <listitem>
                            <para>reconnectTransaction</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* reconnectTransaction(StatusType* status, 
                                   unsigned length, 
                                   const unsigned char* id)
]]>
</programlisting>
                            </para>
                            <para>позволяет подключиться к транзакции в состоянии limbo. Параметр Id
                                содержит номер транзакции в сетевом формате заданной длины.</para>
                        </listitem>
                        <listitem>
                            <para>compileRequest</para>
                            <para><programlisting language="cpp">
<![CDATA[
IRequest* compileRequest(StatusType* status, 
                         unsigned blrLength, 
                         const unsigned char* blr)
]]>
</programlisting>
                            </para>
                            <para>поддержка ISC API.</para>
                        </listitem>
                        <listitem>
                            <para>transactRequest</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void transactRequest(StatusType* status, 
                     ITransaction* transaction, 
                     unsigned blrLength, 
                     const unsigned char* blr, 
                     unsigned inMsgLength, 
                     const unsigned char* inMsg, 
                     unsigned outMsgLength, 
                     unsigned char* outMsg)
]]>
</programlisting>
                            </para>
                            <para>поддержка ISC API.</para>
                        </listitem>
                        <listitem>
                            <para>createBlob</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IBlob* createBlob(StatusType* status, 
                  ITransaction* transaction, 
                  ISC_QUAD* id, 
                  unsigned bpbLength, 
                  const unsigned char* bpb) 
]]>
</programlisting>
                            </para>
                            <para>создает новый blob, сохраняет его идентификатор в id, заменяет
                                    <code>isc_create_blob2()</code>.</para>
                        </listitem>
                        <listitem>
                            <para>openBlob</para>
                            <para><programlisting language="cpp">
<![CDATA[
IBlob* openBlob(StatusType* status, 
                ITransaction* transaction, 
                ISC_QUAD* id, 
                unsigned bpbLength, 
                const unsigned char* bpb) 
]]>
</programlisting>
                            </para>
                            <para>открывает существующий blob, заменяет
                                    <code>isc_open_blob2()</code>.</para>
                        </listitem>
                        <listitem>
                            <para>getSlice</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int getSlice(StatusType* status, 
             ITransaction* transaction, 
             ISC_QUAD* id, 
             unsigned sdlLength, 
             const unsigned char* sdl, 
             unsigned paramLength, 
             const unsigned char* param, 
             int sliceLength, 
             unsigned char* slice)
]]>
</programlisting>
                            </para>
                            <para>поддержка ISC API.</para>
                        </listitem>
                        <listitem>
                            <para>putSlice</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void putSlice(StatusType* status, 
              ITransaction* transaction, 
              ISC_QUAD* id, 
              unsigned sdlLength, 
              const unsigned char* sdl, 
              unsigned paramLength, 
              const unsigned char* param, 
              int sliceLength, 
              unsigned char* slice)
]]>
</programlisting>
                            </para>
                            <para>поддержка ISC API.</para>
                        </listitem>
                        <listitem>
                            <para>executeDyn</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void executeDyn(StatusType* status, 
                ITransaction* transaction, 
                unsigned length, 
                const unsigned char* dyn)
]]>
</programlisting>
                            </para>
                            <para>поддержка ISC API.</para>
                        </listitem>
                        <listitem>
                            <para>prepare</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IStatement* prepare(StatusType* status, 
                    ITransaction* tra, 
                    unsigned stmtLength, 
                    const char* sqlStmt, 
                    unsigned dialect, 
                    unsigned flags) 
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_dsql_prepare()</code>. Дополнительный параметр
                                    <replaceable>flags</replaceable> позволяют контролировать, какая
                                информация будет предварительно загружена из движка сразу (т.е. в
                                одном сетевом пакете для удаленной операции).</para>
                        </listitem>
                        <listitem>
                            <para>execute</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* execute(StatusType* status, 
                      ITransaction* transaction, 
                      unsigned stmtLength, 
                      const char* sqlStmt, 
                      unsigned dialect, 
                      IMessageMetadata* inMetadata, 
                      void* inBuffer, 
                      IMessageMetadata* outMetadata, 
                      void* outBuffer)
]]>
</programlisting>
                            </para>
                            <para>выполняет любую инструкцию SQL, за исключением возврата нескольких
                                строк данных. Частичный аналог <code>isc_dsql_execute2()</code> —
                                вход и выход XSLQDA заменены на входные и выходные сообщения с
                                соответствующими буферами.</para>
                        </listitem>
                        <listitem>
                            <para>openCursor</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IResultSet* openCursor(StatusType* status, 
                       ITransaction* transaction, 
                       unsigned stmtLength, 
                       const char* sqlStmt, 
                       unsigned dialect, 
                       IMessageMetadata* inMetadata, 
                       void* inBuffer, 
                       IMessageMetadata* outMetadata, 
                       const char* cursorName, 
                       unsigned cursorFlags) 
]]>
</programlisting>
                            </para>
                            <para>выполняет оператор SQL, потенциально возвращающий несколько строк
                                данных. Возвращает интерфейс <link
                                    linkend="fbapi-interfaces-iresultset">IResultSet</link>, который
                                используется для извлечения этих данных. Формат выходных данных
                                определяется параметром <replaceable>outMetadata</replaceable>, при
                                задании NULL используется формат по умолчанию. Параметр
                                    <replaceable>cursorName</replaceable> указывает имя открытого
                                курсора (аналог <code>isc_dsql_set_cursor_name()</code>). Параметр
                                    <replaceable>cursorFlags</replaceable> необходим, чтобы открыть
                                двунаправленный указатель курсора, для этого необходимо указать
                                значение <code>IStatement::CURSOR_TYPE_SCROLLABLE</code>.</para>
                        </listitem>
                        <listitem>
                            <para>queEvents</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IEvents* queEvents(StatusType* status, 
                   IEventCallback* callback, 
                   unsigned length, 
                   const unsigned char* events)
]]>
</programlisting>
                            </para>
                            <para>заменяет вызов <code>isc_que_events()</code>. Вместо функции
                                обратного вызова с void* параметром используется интерфейс обратного
                                вызова.</para>
                        </listitem>
                        <listitem>
                            <para>cancelOperation</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void cancelOperation(StatusType* status, int option)
]]>
</programlisting>
                            </para>
                            <para>замена <code>fb_cancel_operation()</code>.</para>
                        </listitem>
                        <listitem>
                            <para>ping</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void ping(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>проверка состояния соединения. Если тест не удаётся, то
                                единственная возможная операция с подключением — закрыть его.</para>
                        </listitem>
                        <listitem>
                            <para>detach</para>
                            <para><programlisting language="cpp">
<![CDATA[
void detach(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_detach_database()</code>. В случае успеха
                                освобождает интерфейс.</para>
                        </listitem>
                        <listitem>
                            <para>dropDatabase</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void dropDatabase(StatusType* status)  
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_drop_database()</code>. В случае успеха
                                освобождает интерфейс.</para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iblob">
                <info>
                    <title>IBlob</title>
                    <keywordset>
                        <keyword>IBlob</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IBlob</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IBlob</interfacename> заменяет
                            <code>isc_blob_handle</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getInfo</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getInfo(StatusType* status, 
             unsigned itemsLength, 
             const unsigned char* items, 
             unsigned bufferLength, 
             unsigned char* buffer)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_blob_info()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>getSegment</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int getSegment(StatusType* status, 
               unsigned bufferLength, 
               void* buffer, 
               unsigned* segmentLength)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_get_segment()</code>. В отличие от него никогда
                                не возвращаются ошибки <code>isc_segstr_eof</code> и
                                    <code>isc_segment</code> (которые на самом деле не являются
                                ошибками), вместо этого возвращаются коды завершения
                                    <code>IStatus::RESULT_NO_DATA</code> и
                                    <code>IStatus::RESULT_SEGMENT</code>, обычно возвращает
                                    <code>IStatus::RESULT_OK</code>.</para>
                        </listitem>
                        <listitem>
                            <para>putSegment</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void putSegment(StatusType* status, 
                unsigned length, 
                const void* buffer)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_put_segment()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>cancel</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void cancel(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_cancel_blob()</code>. В случае успеха
                                освобождает интерфейс.</para>
                        </listitem>
                        <listitem>
                            <para>close</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void close(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_close_blob()</code>. В случае успеха
                                освобождает интерфейс.</para>
                        </listitem>
                        <listitem>
                            <para>seek</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int seek(StatusType* status, 
         int mode, 
         int offset)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_seek_blob()</code>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iconfig">
                <info>
                    <title>IConfig</title>
                    <keywordset>
                        <keyword>IConfig</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IConfig</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IConfig</interfacename> — общий интерфейс файла
                        конфигурации.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>find</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfigEntry* find(StatusType* status, const char* name)
]]>
</programlisting>
                            </para>
                            <para>находит запись по имени. </para>
                        </listitem>
                        <listitem>
                            <para>findValue</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfigEntry* findValue(StatusType* status, const char* name, const char* value)
]]>
</programlisting>
                            </para>
                            <para>находит запись по имени и значению. </para>
                        </listitem>
                        <listitem>
                            <para>findPos</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfigEntry* findPos(StatusType* status, const char* name, unsigned pos)
]]>
</programlisting>
                            </para>
                            <para>находит запись по имени и позиции. Если файл конфигурации содержит
                                строки: <screen>
Db=DBA
Db=DBB
Db=DBC                     
</screen>
                            </para>
                            <para>вызов <code>findPos(status, "Db", 2)</code> вернет запись со
                                значением DBB. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iconfigmanager">
                <info>
                    <title>IConfigManager</title>
                    <keywordset>
                        <keyword>IConfigManager</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IConfigManager</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IConfigManager</interfacename> — общий интерфейс
                        для доступа к различным объектам конфигурации.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getDirectory</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getDirectory(unsigned code)
]]>
</programlisting>
                            </para>
                            <para>возвращает местоположение соответствующего каталога в текущем
                                экземпляре Firebird. См. коды каталогов для этого вызова ниже.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getFirebirdConf</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IFirebirdConf* getFirebirdConf()
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс для доступа к значениям конфигурации по
                                умолчанию (из <filename>firebird.conf</filename>). </para>
                        </listitem>
                        <listitem>
                            <para>getDatabaseConf</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IFirebirdConf* getDatabaseConf(const char* dbName) 
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс для доступа к конфигурации, специфичной для
                                базы данных (берёт в расчёт <filename>firebird.conf</filename> и
                                соответствующую часть <filename>database.conf</filename>). </para>
                        </listitem>
                        <listitem>
                            <para>getPluginConfig</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfig* getPluginConfig(const char* configuredPlugin)
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс для доступа к конфигурации именованного
                                плагина. </para>
                        </listitem>
                        <listitem>
                            <para>getInstallDirectory</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getInstallDirectory() 
]]>
</programlisting>
                            </para>
                            <para>возвращает каталог, в котором установлен firebird. </para>
                        </listitem>
                        <listitem>
                            <para>getRootDirectory</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getRootDirectory() 
]]>
</programlisting>
                            </para>
                            <para>возвращает корневой каталог текущего экземпляра, в случае с
                                единственным экземпляром обычно совпадает с каталогом установки.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>Коды каталогов: <itemizedlist>
                        <listitem>
                            <para>DIR_BIN — <filename>bin</filename> (утилиты наподобие
                                    <application>isql</application>,
                                <application>gbak</application>,
                                <application>gstat</application>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_SBIN — sbin (fbguard и firebird сервер);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_CONF — каталог файлов конфигурации
                                    (<filename>firebird.conf</filename>,
                                    <filename>databases.conf</filename>,
                                    <filename>plugins.conf</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_LIB — <filename>lib</filename> (<filename>fbclient</filename>,
                                    <filename>ib_util</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_INC — <filename>include</filename>
                                    (<filename>ibase.h</filename>,
                                    <filename>firebird/Interfaces.h</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_DOC — каталог документации;</para>
                        </listitem>
                        <listitem>
                            <para>DIR_UDF — UDF (<filename>ib_udf</filename>,
                                    <filename>fbudf</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_SAMPLE — каталог примеров;</para>
                        </listitem>
                        <listitem>
                            <para>DIR_SAMPLEDB — каталог где расположена база данных примеров
                                    (<filename>employee.fdb</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_HELP — qli help (<filename>help.fdb</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_INTL — каталог библиотек интернационализации
                                    (<filename>fbintl</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_MISC — различные файлы (как манифест деинсталлятора и
                                другое);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_SECDB — каталог где хранится база данных безопасности
                                    (<filename>securityN.fdb</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_MSG — каталог где хранится файл сообщений
                                    (<filename>firebird.msg</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_LOG — каталог где хранится лог файл
                                    (<filename>firebird.log</filename>);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_GUARD — каталог где хранится блокировка хранителя
                                (fb_guard);</para>
                        </listitem>
                        <listitem>
                            <para>DIR_PLUGINS — директория плагинов ([lib]Engine12.{dll|so}).</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <section xml:id="fbapi-interfaces-iconfigentry">
                <info>
                    <title>IConfigEntry</title>
                    <keywordset>
                        <keyword>IConfigEntry</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IConfigEntry</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IConfigEntry</interfacename> — представляет
                        запись (Key = Values с возможными подзаголовками (подзаписями)) в файле
                        конфигурации firebird.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getName()
]]>
</programlisting>
                            </para>
                            <para>возвращает имя ключа. </para>
                        </listitem>
                        <listitem>
                            <para>getValue</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getValue()
]]>
</programlisting>
                            </para>
                            <para>возвращает значение в качестве символьной строки. </para>
                        </listitem>
                        <listitem>
                            <para>getIntValue</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ISC_INT64 getIntValue()
]]>
</programlisting>
                            </para>
                            <para>обрабатывает значение как целое и возвращает его. </para>
                        </listitem>
                        <listitem>
                            <para>getBoolValue</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN getBoolValue() 
]]>
</programlisting>
                            </para>
                            <para>обрабатывает значение как boolean и возвращает его. </para>
                        </listitem>
                        <listitem>
                            <para>getSubConfig</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfig* getSubConfig(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>рассматривает подзаголовки как отдельный файл конфигурации и
                                возвращает интерфейс IConfig для него. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-idtc">
                <info>
                    <title>IDtc</title>
                    <keywordset>
                        <keyword>IDtc</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IDtc</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IDtc</interfacename> — координатор распределенных
                        транзакций. Используется для запуска распределенной (работает с двумя или
                        более подключениями) транзакции. В отличие от пред-FB3-подхода, когда
                        распределенная транзакция должна запускаться таким образом с самого начала,
                        координатор распределенных транзакций Firebird 3 позволяет также
                        присоединить уже запущенные транзакции в единую распределенную
                        транзакцию.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>join</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* join(StatusType* status, ITransaction* one, ITransaction* two)
]]>
</programlisting>
                            </para>
                            <para>объединяет 2 независимых транзакции в распределенную транзакцию.
                                При успешном выполнении обе транзакции, переданные в
                                    <code>join()</code>, освобождаются, а указатели на них больше не
                                должны использоваться. </para>
                        </listitem>
                        <listitem>
                            <para>startBuilder</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IDtcStart* startBuilder(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>возвращает <link linkend="fbapi-interfaces-idtcstart"
                                    >IDtcStart</link> интерфейс. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-idtcstart">
                <info>
                    <title>IDtcStart</title>
                    <keywordset>
                        <keyword>IDtcStart</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IDtcStart</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IDtcStart</interfacename> — заменяет массив
                        структур TEB (передан <code>isc_start_multiple()</code> в ISC API). Этот
                        интерфейс собирает подключения (и, вероятно, соответствующие TPB), для
                        которых должна быть запущена распределённая транзакция.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>addAttachment</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void addAttachment(StatusType* status, IAttachment* att) 
]]>
</programlisting>
                            </para>
                            <para>добавляет подключение, транзакция для него будет запущена с TPB по
                                умолчанию. </para>
                        </listitem>
                        <listitem>
                            <para>addWithTpb</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void addWithTpb(StatusType* status, IAttachment* att, unsigned length, const unsigned char* tpb) 
]]>
</programlisting>
                            </para>
                            <para>добавляет подключение и TPB, которые будут использоваться для
                                запуска транзакции для этого подключения. </para>
                        </listitem>
                        <listitem>
                            <para>start</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* start(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>начинает распределенную транзакцию для собранных подключений. При
                                успехе возвращает интерфейс
                                <interfacename>IDtcStart</interfacename>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ieventcallback">
                <info>
                    <title>IEventCallback</title>
                    <keywordset>
                        <keyword>IEventCallback</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IEventCallback</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IEventCallback</interfacename> — заменяет функцию
                        обратного вызова, используемую в вызове <code>isc_que_events()</code>.
                        Должен быть реализован пользователем для отслеживания событий с помощью
                        метода <code>IAttachment::queEvents()</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>eventCallbackFunction</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void eventCallbackFunction(unsigned length, const unsigned char* events)
]]>
</programlisting>
                            </para>
                            <para>вызывается каждый раз, когда происходит событие. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ievents">
                <info>
                    <title>IEvents</title>
                    <keywordset>
                        <keyword>IEvents</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IEvents</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IEvents</interfacename> — заменяет идентификатор
                        события при работе с мониторингом событий.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>cancel</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void cancel(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>отменяет мониторинг событий, начатый в
                                    <code>IAttachment::queEvents()</code>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ifirebirdconf">
                <info>
                    <title>IFirebirdConf</title>
                    <keywordset>
                        <keyword>IFirebirdConf</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IFirebirdConf</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IFirebirdConf</interfacename> — доступ к основной
                        конфигурации Firebird. Используется как для конфигурации по умолчанию,
                        заданной конфигурацией <filename>firebird.conf</filename>, так и для каждой
                        базы данных, скорректированной с помощью <filename>database.conf</filename>.
                        Чтобы ускорить доступ к значениям конфигурации, вызовы, обращающиеся к
                        фактическим значениям, используют целочисленный ключ вместо символьного
                        имени параметра. Ключ стабилен во время работы сервера (т. е. плагин может
                        получить его один раз и использовать для получения значения параметров
                        конфигурации для разных баз данных).</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getKey(const char* name)
]]>
</programlisting>
                            </para>
                            <para>возвращает ключ для заданного имени параметра. ~0 (все биты равны
                                1) возвращается в случае, когда такого параметра нет.</para>
                        </listitem>
                        <listitem>
                            <para>asInteger</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ISC_INT64 asInteger(unsigned key)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение целочисленного параметра. </para>
                        </listitem>
                        <listitem>
                            <para>asString</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* asString(unsigned key)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение строкового параметра </para>
                        </listitem>
                        <listitem>
                            <para>asBoolean</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN asBoolean(unsigned key) 
]]>
</programlisting>
                            </para>
                            <para>возвращает значение логического параметра. Стандартные
                                аббревиатуры (1/true/t/yes/y) рассматриваются как true, все
                                остальные — как false. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-imaster">
                <info>
                    <title>IMaster</title>
                    <keywordset>
                        <keyword>IMaster</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IMaster</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para><interfacename>IMaster</interfacename> — основной интерфейс, с которого
                        начинаются все операции с API-интерфейсом Firebird.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getStatus</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IStatus* getStatus() 
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-istatus">IStatus</link>. </para>
                        </listitem>
                        <listitem>
                            <para>getDispatcher</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IProvider* getDispatcher()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-iprovider">IProvider</link>,
                                реализованный YValve (основной экземпляр поставщика). </para>
                        </listitem>
                        <listitem>
                            <para>getPluginManager</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IPluginManager* getPluginManager()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-ipluginmanager">IPluginManager</link>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getTimerControl</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITimerControl* getTimerControl()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-itimercontrol">ITimerControl</link>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getDtc</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IDtc* getDtc()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-idtc">IDtc</link>. </para>
                        </listitem>
                        <listitem>
                            <para>getUtilInterface</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IUtil* getUtilInterface()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-iutil">IUtil</link>. </para>
                        </listitem>
                        <listitem>
                            <para>getConfigManager</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfigManager* getConfigManager()
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр интерфейса <link
                                    linkend="fbapi-interfaces-iconfigmanager">IConfigManager</link>.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-imessagemetadata">
                <info>
                    <title>IMessageMetadata</title>
                    <keywordset>
                        <keyword>IMessageMetadata</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IMessageMetadata</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>MessageMetadata</interfacename> — частичный
                        аналог XSQLDA (не содержит данных сообщений, присутствует только информация
                        о формате сообщения). Используется в вызовах, связанных с выполнением
                        операторов SQL.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getCount</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getCount(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает количество полей/параметров в сообщении. Во всех
                                вызовах, содержащих индексный параметр, это значение должно быть: 0
                                &lt;= index &lt; getCount(). </para>
                        </listitem>
                        <listitem>
                            <para>getField</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getField(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает имя поля. </para>
                        </listitem>
                        <listitem>
                            <para>getRelation</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getRelation(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает имя отношения (из которого выбрано данное поле).
                            </para>
                        </listitem>
                        <listitem>
                            <para>getOwner</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getOwner(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает имя владельца отношения. </para>
                        </listitem>
                        <listitem>
                            <para>getAlias</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getAlias(StatusType* status, unsigned index) 
]]>
</programlisting>
                            </para>
                            <para>возвращает псевдоним поля. </para>
                        </listitem>
                        <listitem>
                            <para>getType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getType(StatusType* status, unsigned index) 
]]>
</programlisting>
                            </para>
                            <para>возвращает SQL тип поля. </para>
                        </listitem>
                        <listitem>
                            <para>isNullable</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN isNullable(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает true, если поле может принимать значение NULL. </para>
                        </listitem>
                        <listitem>
                            <para>getSubType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int getSubType(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает подтип поля BLOB (0 - двоичный, 1 - текст и т. д.).
                            </para>
                        </listitem>
                        <listitem>
                            <para>getLength</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getLength(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает максимальную длину поля. </para>
                        </listitem>
                        <listitem>
                            <para>getScale</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int getScale(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает масштаб для числового поля. </para>
                        </listitem>
                        <listitem>
                            <para>getCharSet</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getCharSet(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>возвращает набор символов для символьных полей и текстового BLOB.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getOffset</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getOffset(StatusType* status, unsigned index) 
]]>
</programlisting>
                            </para>
                            <para>возвращает смещение данных поля в буфере сообщений (используйте
                                его для доступа к данным в буфере сообщений). </para>
                        </listitem>
                        <listitem>
                            <para>getNullOffset</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getNullOffset(StatusType* status, unsigned index)  
]]>
</programlisting>
                            </para>
                            <para>возвращает смещение NULL индикатора для поля в буфере сообщений.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getBuilder</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IMetadataBuilder* getBuilder(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс <link
                                    linkend="fbapi-interfaces-imetadatabuilder"
                                    >IMetadataBuilder</link>, инициализированный метаданными этого
                                сообщения. </para>
                        </listitem>
                        <listitem>
                            <para>getMessageLength</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getMessageLength(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает длину буфера сообщения (используйте его для выделения
                                памяти под буфер). </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-imetadatabuilder">
                <info>
                    <title>IMetadataBuilder</title>
                    <keywordset>
                        <keyword>IMetadataBuilder</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IMetadataBuilder</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IMetadataBuilder</interfacename> — позволяет
                        описать типы данных для существующих сообщений или создавать метаданные с
                        самого начала.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>setType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setType(StatusType* status, unsigned index, unsigned type)
]]>
</programlisting>
                            </para>
                            <para>устанавливает SQL тип поля. </para>
                        </listitem>
                        <listitem>
                            <para>setSubType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setSubType(StatusType* status, unsigned index, int subType)
]]>
</programlisting>
                            </para>
                            <para>устанавливает подтип BLOB поля. </para>
                        </listitem>
                        <listitem>
                            <para>setLength</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setLength(StatusType* status, unsigned index, unsigned length)
]]>
</programlisting>
                            </para>
                            <para>устанавливает максимальную длину символьного поля. </para>
                        </listitem>
                        <listitem>
                            <para>setCharSet</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setCharSet(StatusType* status, unsigned index, unsigned charSet)
]]>
</programlisting>
                            </para>
                            <para>устанавливает набор символов для символьного поля и текстового
                                BLOB. </para>
                        </listitem>
                        <listitem>
                            <para>setScale</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setScale(StatusType* status, unsigned index, unsigned scale) 
]]>
</programlisting>
                            </para>
                            <para>устанавливает масштаб для числовых полей. </para>
                        </listitem>
                        <listitem>
                            <para>truncate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void truncate(StatusType* status, unsigned count)
]]>
</programlisting>
                            </para>
                            <para>обрезает сообщение чтобы оно содержало не более
                                    <replaceable>count</replaceable> полей. </para>
                        </listitem>
                        <listitem>
                            <para>moveNameToIndex</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void moveNameToIndex(StatusType* status, const char* name, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>реорганизует поля в сообщении — перемещает поле с именем
                                    <replaceable>name</replaceable> в заданное положение. </para>
                        </listitem>
                        <listitem>
                            <para>remove</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void remove(StatusType* status, unsigned index)
]]>
</programlisting>
                            </para>
                            <para>удаляет поле. </para>
                        </listitem>
                        <listitem>
                            <para>addField</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned addField(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>добавляет поле. </para>
                        </listitem>
                        <listitem>
                            <para>getMetadata</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IMessageMetadata* getMetadata(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс <link
                                    linkend="fbapi-interfaces-imessagemetadata"
                                    >IMessageMetadata</link>, построенный этим построителем. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ioffsetscallback">
                <info>
                    <title>IOffsetsCallback</title>
                    <keywordset>
                        <keyword>IOffsetsCallback</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IOffsetsCallback</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс IOffsetsCallback</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>setOffset</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setOffset(StatusType* status, unsigned index, unsigned offset, unsigned nullOffset)
]]>
</programlisting>
                            </para>
                            <para>уведомляет, что должны быть установлены смещения для
                                поля/параметра с индексом <replaceable>index</replaceable>. Должен
                                быть реализован пользователем при реализации интерфейса <link
                                    linkend="fbapi-interfaces-imessagemetadata"
                                    >MessageMetadata</link> и с использованием
                                    <methodname>IUtil::setOffsets()</methodname>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ipluginconfig">
                <info>
                    <title>IPluginConfig</title>
                    <keywordset>
                        <keyword>IPluginConfig</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IPluginConfig</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginConfig</interfacename> — передается
                        фабрике плагинов при создании экземпляра плагина (с конкретной
                        конфигурацией).</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getConfigFileName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getConfigFileName()
]]>
</programlisting>
                            </para>
                            <para>возвращает рекомендованное имя файла, в котором ожидается
                                сохранение конфигурации для плагина. </para>
                        </listitem>
                        <listitem>
                            <para>getDefaultConfig</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfig* getDefaultConfig(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>конфигурация плагина, загруженная по стандартным правилам. </para>
                        </listitem>
                        <listitem>
                            <para>getFirebirdConf</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IFirebirdConf* getFirebirdConf(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает главную конфигурацию Firebird с учётом настроек для
                                базы данных, с которой будет работать новый экземпляр плагина.
                            </para>
                        </listitem>
                        <listitem>
                            <para>setReleaseDelay</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setReleaseDelay(StatusType* status, ISC_UINT64 microSeconds) 
]]>
</programlisting>
                            </para>
                            <para>используемые плагином для настройки рекомендуемой задержки, в
                                течение которой модуль плагина не будет выгружен менеджером плагинов
                                после освобождения последнего экземпляра плагина из этого модуля.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ipluginfactory">
                <info>
                    <title>IPluginFactory</title>
                    <keywordset>
                        <keyword>IPluginFactory</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IPluginFactory</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginFactory</interfacename> — должен быть
                        реализован автором плагина при написании плагина.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>createPlugin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IPluginBase* createPlugin(StatusType* status, IPluginConfig* factoryParameter)
]]>
</programlisting>
                            </para>
                            <para>создает новый экземпляр плагина с переданной рекомендуемой
                                конфигурацией. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ipluginmanager">
                <info>
                    <title>IPluginManager</title>
                    <keywordset>
                        <keyword>IPluginManager</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IPluginManager</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginManager</interfacename> — API диспетчера
                        плагинов.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>registerPluginFactory</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void registerPluginFactory(unsigned pluginType, 
                           const char* defaultName, 
                           IPluginFactory* factory)
]]>
</programlisting>
                            </para>
                            <para>регистрирует именованную фабрику плагинов данного типа. </para>
                        </listitem>
                        <listitem>
                            <para>registerModule</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void registerModule(IPluginModule* cleanup)
]]>
</programlisting>
                            </para>
                            <para>регистрирует модуль плагина. </para>
                        </listitem>
                        <listitem>
                            <para>unregisterModule</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void unregisterModule(IPluginModule* cleanup)
]]>
</programlisting>
                            </para>
                            <para>разрегистрирует модуль плагина. </para>
                        </listitem>
                        <listitem>
                            <para>getPlugins</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IPluginSet* getPlugins(StatusType* status, 
                       unsigned pluginType, 
                       const char* namesList, 
                       IFirebirdConf* firebirdConf)
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс <interfacename>IPluginSet</interfacename>,
                                предоставляющий доступ к списку плагинов данного типа. Имена
                                включенных плагинов берутся из <replaceable>namesList</replaceable>,
                                если отсутствует (NULL), то из настроек конфигурации для данного
                                типа <replaceable>pluginType</replaceable>. Если указан параметр
                                    <replaceable>firebirdConf</replaceable>, то он используется для
                                всех целей конфигурации (включая получение списка плагинов и переход
                                к методу <methodname>PluginFactory::createPlugin()</methodname>),
                                если отсутствует (NULL), то используется настройка по умолчанию (из
                                    <filename>firebird.conf</filename>). </para>
                        </listitem>
                        <listitem>
                            <para>getConfig</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IConfig* getConfig(StatusType* status, const char* filename) 
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс <interfacename>IConfig</interfacename> для
                                заданного имени файла конфигурации. Может использоваться плагинами
                                для доступа к файлам конфигурации со стандартным форматом, но не с
                                именем по умолчанию. </para>
                        </listitem>
                        <listitem>
                            <para>releasePlugin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void releasePlugin(IPluginBase* plugin)
]]>
</programlisting>
                            </para>
                            <para>освобождение данного плагина. Должен использоваться для плагинов
                                вместо простой <code>release()</code> из-за необходимости выполнять
                                дополнительные действия с владельцем плагина до фактического
                                выпуска. </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>Константы, определенные интерфейсом IPluginManager (типы
                        плагинов):<itemizedlist spacing="compact">
                        <listitem>
                            <para>TYPE_PROVIDER</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_AUTH_SERVER</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_AUTH_CLIENT</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_AUTH_USER_MANAGEMENT</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_EXTERNAL_ENGINE</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_TRACE</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_WIRE_CRYPT</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_DB_CRYPT</para>
                        </listitem>
                        <listitem>
                            <para>TYPE_KEY_HOLDER</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <section xml:id="fbapi-interfaces-ipluginmodule">
                <info>
                    <title>IPluginModule</title>
                    <keywordset>
                        <keyword>IPluginModule</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IPluginModule</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginModule</interfacename> — представляет
                        модуль плагина (динамическая библиотека). Должен быть реализован автором
                        плагина в каждом модуле плагина (по одному экземпляру на модуль).</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>doClean</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void doClean() 
]]>
</programlisting>
                            </para>
                            <para>вызывается диспетчером плагинов перед нормальной выгрузкой модуля
                                плагина. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ipluginset">
                <info>
                    <title>IPluginSet</title>
                    <keywordset>
                        <keyword>IPluginSet</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IPluginSet</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginSet</interfacename> — представляет собой
                        набор плагинов данного типа. Обычно используется внутренним кодом Firebird,
                        но рекомендуется для использования в плагинах, загружающих другие
                        плагины.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getName() 
]]>
</programlisting>
                            </para>
                            <para>возвращает имя текущего плагина в наборе. </para>
                        </listitem>
                        <listitem>
                            <para>getModuleName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getModuleName()
]]>
</programlisting>
                            </para>
                            <para>возвращает имя модуля текущего плагина в наборе (в простом случае
                                совпадает с именем плагина). </para>
                        </listitem>
                        <listitem>
                            <para>getPlugin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IPluginBase* getPlugin(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает экземпляр текущего плагина, возвращенный интерфейс
                                должен быть преобразован в основной интерфейс плагина запрошенного
                                типа в методе <methodname>IPluginManager::getPlugins()</methodname>.
                                Возвращает NULL, если в наборе больше нет плагинов. Счётчик ссылок
                                плагина, возвращаемого этой функцией, увеличивается при возврате —
                                не забудьте использовать метод
                                    <methodname>releasePlugin()</methodname> интерфейса <link
                                    linkend="fbapi-interfaces-ipluginmanager">IPluginManager</link>
                                для освобождения плагинов, возвращаемых этим методом. </para>
                        </listitem>
                        <listitem>
                            <para>next</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void next(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>устанавливает переключатель для перехода к следующему плагину из
                                списка. </para>
                        </listitem>
                        <listitem>
                            <para>set</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void set(StatusType* status, const char* list) 
]]>
</programlisting>
                            </para>
                            <para>сбрасывает интерфейс: заставляет его работать со списком плагинов,
                                предоставляемых параметром списка. Тип плагинов остается неизменным.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iprovider">
                <info>
                    <title>IProvider</title>
                    <keywordset>
                        <keyword>IProvider</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IProvider</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IPluginModule</interfacename> — основной
                        интерфейс для начала доступа к базе данных/сервису.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>attachDatabase</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IAttachment* attachDatabase(StatusType* status, 
                            const char* fileName, 
                            unsigned dpbLength, 
                            const unsigned char* dpb)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_attach_database()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>createDatabase</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IAttachment* createDatabase(StatusType* status, 
                            const char* fileName, 
                            unsigned dpbLength, 
                            const unsigned char* dpb)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_create_database()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>attachServiceManager</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IService* attachServiceManager(StatusType* status, 
                               const char* service, 
                               unsigned spbLength, 
                               const unsigned char* spb)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_service_attach()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>shutdown</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void shutdown(StatusType* status, unsigned timeout, const int reason)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>fb_shutdown()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>setDbCryptCallback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setDbCryptCallback(IStatus* status, ICryptKeyCallback* cryptCallback)
]]>
</programlisting>
                            </para>
                            <para>устанавливает интерфейс обратного вызова шифрования базы данных,
                                который будет использоваться для последующих подключений к базе
                                данных и сервисам. См. ... для подробностей. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iresultset">
                <info>
                    <title>IResultSet</title>
                    <keywordset>
                        <keyword>IResultSet</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IResultSet</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IResultSet</interfacename> — заменяет (с
                        расширенной функциональностью) некоторые функции
                            <code>isc_stmt_handle</code>. Этот интерфейс возвращается вызовом
                            <methodname>openCursor()</methodname> из <link
                            linkend="fbapi-interfaces-iattachment">IAttachment</link> или <link
                            linkend="fbapi-interfaces-istatement">IStatement</link>. Все вызовы
                            <code>fetch...</code>, кроме <methodname>fetchNext()</methodname>,
                        работают только для двунаправленного (открытого с флагом
                            <code>CURSOR_TYPE_SCROLLABLE</code>) курсора.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>fetchNext</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchNext(StatusType* status, void* message)
]]>
</programlisting>
                            </para>
                            <para>выбирает следующую запись, заменяет <code>isc_dsql_fetch()</code>.
                                Этот метод (и другие методы выборки) возвращает код завершения
                                    <code>Status::RESULT_NO_DATA</code> при достижении EOF, и статус
                                    <code>Status::RESULT_OK</code> при успешном завершении.</para>
                        </listitem>
                        <listitem>
                            <para>fetchPrior</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchPrior(StatusType* status, void* message)
]]>
</programlisting>
                            </para>
                            <para>выбирает предыдущую запись. </para>
                        </listitem>
                        <listitem>
                            <para>fetchFirst</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchFirst(StatusType* status, void* message)
]]>
</programlisting>
                            </para>
                            <para>выбирает первую запись. </para>
                        </listitem>
                        <listitem>
                            <para>fetchLast</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchLast(StatusType* status, void* message) 
]]>
</programlisting>
                            </para>
                            <para>выбирает последнюю запись. </para>
                        </listitem>
                        <listitem>
                            <para>fetchAbsolute</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchAbsolute(StatusType* status, int position, void* message) 
]]>
</programlisting>
                            </para>
                            <para>получает запись по абсолютной позиции в наборе результатов.
                            </para>
                        </listitem>
                        <listitem>
                            <para>fetchRelative</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int fetchRelative(StatusType* status, int offset, void* message)
]]>
</programlisting>
                            </para>
                            <para>извлекает запись по положению относительно текущей. </para>
                        </listitem>
                        <listitem>
                            <para>isEof</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN isEof(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>проверка EOF. </para>
                        </listitem>
                        <listitem>
                            <para>isBof</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN isBof(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>проверка BOF. </para>
                        </listitem>
                        <listitem>
                            <para>getMetadata</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IMessageMetadata* getMetadata(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает метаданные для сообщений в наборе результатов, особенно
                                полезно, когда набор результатов открывается вызовом
                                    <code>IAttachment::openCursor()</code> с параметром формата
                                вывода метаданных равным NULL (это единственный способ получить
                                формат сообщения в данном случае).</para>
                        </listitem>
                        <listitem>
                            <para>close</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void close(IStatus* status) 
]]>
</programlisting>
                            </para>
                            <para>закрывает набор результатов, освобождает интерфейс в случае
                                успеха. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iservice">
                <info>
                    <title>IService</title>
                    <keywordset>
                        <keyword>IService</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IService</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IService</interfacename> — заменяет
                            <code>isc_svc_handle</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>detach</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void detach(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>закрывает подключение к менеджеру сервисов, при успехе освобождает
                                интерфейс. Заменяет <code>isc_service_detach()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>query</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void query(StatusType* status, 
           unsigned sendLength, 
           const unsigned char* sendItems, 
           unsigned receiveLength, 
           const unsigned char* receiveItems, 
           unsigned bufferLength, 
           unsigned char* buffer)
]]>
</programlisting>
                            </para>
                            <para>отправляет и запрашивает информацию в/из службы, при этом
                                    <replaceable>receiveItems</replaceable> могут использоваться как
                                для запущенных служб, так и для получения различной информации по
                                всему серверу. Заменяет <code>isc_service_query()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>start</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void start(StatusType* status, 
           unsigned spbLength, 
           const unsigned char* spb) 
]]>
</programlisting>
                            </para>
                            <para>запускает утилиту в диспетчере служб. Заменяет
                                    <code>isc_service_start()</code>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-istatement">
                <info>
                    <title>IStatement</title>
                    <keywordset>
                        <keyword>IStatement</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IStatement</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IStatement</interfacename> — заменяет (частично)
                            <code>isc_stmt_handle</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getInfo</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getInfo(StatusType* status, 
             unsigned itemsLength, 
             const unsigned char* items, 
             unsigned bufferLength, 
             unsigned char* buffer)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_dsql_sql_info()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>getType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getType(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>тип оператора, в настоящее время можно найти только в источниках
                                firebird в <filename>dsql/dsql.h</filename>. </para>
                        </listitem>
                        <listitem>
                            <para>getPlan</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getPlan(StatusType* status, FB_BOOLEAN detailed) 
]]>
</programlisting>
                            </para>
                            <para>возвращает план выполнения оператора. </para>
                        </listitem>
                        <listitem>
                            <para>getAffectedRecords</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ISC_UINT64 getAffectedRecords(StatusType* status)  
]]>
</programlisting>
                            </para>
                            <para>возвращает количество записей, которые затронуты оператором.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getInputMetadata</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IMessageMetadata* getInputMetadata(StatusType* status)  
]]>
</programlisting>
                            </para>
                            <para>возвращает метаданные параметров. </para>
                        </listitem>
                        <listitem>
                            <para>getOutputMetadata</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IMessageMetadata* getOutputMetadata(StatusType* status)  
]]>
</programlisting>
                            </para>
                            <para>возвращает метаданные значений выходных данных. </para>
                        </listitem>
                        <listitem>
                            <para>execute</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* execute(StatusType* status, 
                      ITransaction* transaction, 
                      IMessageMetadata* inMetadata, 
                      void* inBuffer, 
                      IMessageMetadata* outMetadata, 
                      void* outBuffer)   
]]>
</programlisting>
                            </para>
                            <para>выполняет любую инструкцию SQL, за исключением тех, что возвращают
                                нескольких строк данных. Частичный аналог
                                    <code>isc_dsql_execute2()</code> — вход и выход XSLQDA заменены
                                на входные и выходные сообщения с соответствующими буферами. </para>
                        </listitem>
                        <listitem>
                            <para>openCursor</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IResultSet* openCursor(StatusType* status, 
                       ITransaction* transaction, 
                       IMessageMetadata* inMetadata, 
                       void* inBuffer, 
                       IMessageMetadata* outMetadata, 
                       unsigned flags)   
]]>
</programlisting>
                            </para>
                            <para>выполняет оператор SQL, потенциально возвращающий несколько строк
                                данных. Возвращает интерфейс
                                    <interfacename>IResultSet</interfacename>, который должен
                                использоваться для извлечения этих данных. Формат выходных данных
                                определяется параметром <replaceable>outMetadata</replaceable>, если
                                указано NULL, то будет использоваться формат по умолчанию.</para>
                        </listitem>
                        <listitem>
                            <para>setCursorName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setCursorName(StatusType* status, const char* name)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_dsql_set_cursor_name()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>free</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void free(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>уничтожает оператор, освобождает интерфейс в случае успеха.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getFlags</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getFlags(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает флаги, описывающие, как должен выполняться этот
                                оператор, упрощенная замена метода
                                    <methodname>getType()</methodname>. </para>
                        </listitem>
                    </orderedlist>
                </para>
                <section>
                    <title>Константы, определенные интерфейсом IStatement</title>
                    <para>Флаги <methodname>IAttachment::prepare()</methodname>: <itemizedlist
                            spacing="compact">
                            <listitem>
                                <para><code>PREPARE_PREFETCH_NONE</code> — константа, чтобы
                                    пропускать флаги, значение 0.</para>
                            </listitem>
                        </itemizedlist> Следующие флаги могут быть объединены с помощью
                            <code>OR</code> для получения желаемого эффекта: <orderedlist
                            spacing="compact">
                            <listitem>
                                <para><code>PREPARE_PREFETCH_TYPE</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_INPUT_PARAMETERS</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_OUTPUT_PARAMETERS</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_LEGACY_PLAN</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_DETAILED_PLAN</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_AFFECTED_RECORDS</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_FLAGS</code> (флаги возвращаемые
                                    методом <methodname>getFlags()</methodname>)</para>
                            </listitem>
                        </orderedlist> Для наиболее часто используемых комбинаций флагов можно
                        использовать константы: <orderedlist spacing="compact">
                            <listitem>
                                <para><code>PREPARE_PREFETCH_METADATA</code></para>
                            </listitem>
                            <listitem>
                                <para><code>PREPARE_PREFETCH_ALL</code></para>
                            </listitem>
                        </orderedlist></para>
                    <para>Значения возвращаемые методом <methodname>getFlags()</methodname>: <orderedlist>
                            <listitem>
                                <para><code>FLAG_HAS_CURSOR</code> — используйте
                                        <methodname>openCursor()</methodname> для выполнения этого
                                    оператора, а не <methodname>execute()</methodname></para>
                            </listitem>
                            <listitem>
                                <para><code>FLAG_REPEAT_EXECUTE</code> — когда подготовленный
                                    оператор может выполняться много раз с разными
                                    параметрами.</para>
                            </listitem>
                        </orderedlist></para>
                    <para>Флаги передаваемые в <methodname>openCursor()</methodname>: <itemizedlist>
                            <listitem>
                                <para><code>CURSOR_TYPE_SCROLLABLE</code> — открывается
                                    двунаправленный курсор.</para>
                            </listitem>
                        </itemizedlist></para>
                </section>
            </section>
            <section xml:id="fbapi-interfaces-istatus">
                <info>
                    <title>IStatus</title>
                    <keywordset>
                        <keyword>IStatus</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IStatus</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IStatus</interfacename> — заменяет
                            <code>ISC_STATUS_ARRAY</code>. Функциональность расширена — статус имеет
                        отдельный доступ к векторам ошибок и предупреждений, может содержать векторы
                        неограниченной длины, самостоятельно хранит строки, используемые в векторах,
                        не имеет необходимости в кольцевом буфере строк. В C++
                            <interfacename>IStatus</interfacename> всегда используется в оболочке
                        состояния, C++ API предоставляет две разные оболочки, имеющие различное
                        поведение, когда ошибка возвращается из вызова API. Интерфейс сведен к
                        минимуму (методы, такие как преобразование его в текст, перемещены в
                        интерфейс <link linkend="fbapi-interfaces-iutil">IUtil</link>), чтобы
                        упростить его реализацию пользователями при необходимости.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>init</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void init()
]]>
</programlisting>
                            </para>
                            <para>очищает интерфейс, устанавливая его в исходное состояние. </para>
                        </listitem>
                        <listitem>
                            <para>getState</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getState()
]]>
</programlisting>
                            </para>
                            <para>возвращает текущее состояние интерфейса, возвращаемые флаги могут
                                быть объединены с помощью <code>OR</code>. </para>
                        </listitem>
                        <listitem>
                            <para>setErrors2</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setErrors2(unsigned length, const intptr_t* value)
]]>
</programlisting>
                            </para>
                            <para>устанавливает содержимое вектора ошибок с длиной, явно указанной в
                                вызове. </para>
                        </listitem>
                        <listitem>
                            <para>setWarnings2</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setWarnings2(unsigned length, const intptr_t* value)
]]>
</programlisting>
                            </para>
                            <para>устанавливает содержимое вектора предупреждений с длиной, явно
                                указанной в вызове. </para>
                        </listitem>
                        <listitem>
                            <para>setErrors</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setErrors(const intptr_t* value) 
]]>
</programlisting>
                            </para>
                            <para>устанавливает содержимое вектора ошибок, длина определяется
                                контекстом значения. </para>
                        </listitem>
                        <listitem>
                            <para>setWarnings</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setWarnings(const intptr_t* value)  
]]>
</programlisting>
                            </para>
                            <para>устанавливает содержимое вектора предупреждений, длина
                                определяется контекстом значения. </para>
                        </listitem>
                        <listitem>
                            <para>getErrors</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const intptr_t* getErrors()
]]>
</programlisting>
                            </para>
                            <para>возвращает вектор ошибок. </para>
                        </listitem>
                        <listitem>
                            <para>getWarnings</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const intptr_t* getWarnings()
]]>
</programlisting>
                            </para>
                            <para>возвращает вектор предупреждений. </para>
                        </listitem>
                        <listitem>
                            <para>clone</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IStatus* clone()
]]>
</programlisting>
                            </para>
                            <para>создаёт клон текущего интерфейса. </para>
                        </listitem>
                    </orderedlist>
                </para>
                <section>
                    <title>Константы определённые в IStatus</title>
                    <para>Флаги, возвращаемые методом <methodname>getState()</methodname>:<itemizedlist>
                            <listitem>
                                <para><code>STATE_WARNINGS</code></para>
                            </listitem>
                            <listitem>
                                <para><code>STATE_ERRORS</code></para>
                            </listitem>
                        </itemizedlist></para>
                    <para>Коды завершения: <itemizedlist>
                            <listitem>
                                <para><code>RESULT_ERROR</code></para>
                            </listitem>
                            <listitem>
                                <para><code>RESULT_OK</code></para>
                            </listitem>
                            <listitem>
                                <para><code>RESULT_NO_DATA</code></para>
                            </listitem>
                            <listitem>
                                <para><code>RESULT_SEGMENT</code></para>
                            </listitem>
                        </itemizedlist></para>
                </section>
            </section>
            <section xml:id="fbapi-interfaces-itimer">
                <info>
                    <title>ITimer</title>
                    <keywordset>
                        <keyword>ITimer</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>ITimer</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ITimer</interfacename> — пользовательский таймер.
                        Интерфейс обратного вызова, который должен быть реализован пользователем для
                        использования таймера Firebird.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>handler</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void handler()
]]>
</programlisting>
                            </para>
                            <para>метод вызывается, когда таймер звонит (или когда сервер
                                выключается). </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-itimercontrol">
                <info>
                    <title>ITimerControl</title>
                    <keywordset>
                        <keyword>ITimerControl</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>ITimerControl</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ITimerControl</interfacename> — очень простая и
                        не слишком точная реализация таймера. Прибыл сюда, потому что существующие
                        таймеры очень зависимы от ОС и могут использоваться в программах, которые
                        требуют переносимости и не требуют действительно высокоточного таймера. В
                        частности, выполнение данного таймера может быть отложено, если другой не
                        был завершен в тот момент, когда данный таймер должен
                        сигнализировать.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>start</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void start(StatusType* status, ITimer* timer, ISC_UINT64 microSeconds)
]]>
</programlisting>
                            </para>
                            <para>запуск <link linkend="fbapi-interfaces-itimer">ITimer</link> после
                                сигнала (в микросекундах, 10<superscript>-6</superscript> секунд).
                                Таймер будет разбужен только один раз после этого вызова.</para>
                        </listitem>
                        <listitem>
                            <para>stop</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void stop(StatusType* status, ITimer* timer)
]]>
</programlisting>
                            </para>
                            <para>остановка <link linkend="fbapi-interfaces-itimer">ITimer</link>.
                                Не стоит останавливать не запущенный таймер, что позволит избежать
                                проблем с гонками между <methodname>stop()</methodname> и сигналом
                                таймером. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-itransaction">
                <info>
                    <title>ITransaction</title>
                    <keywordset>
                        <keyword>ITransaction</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>ITransaction</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ITransaction</interfacename> — заменяет
                            <code>isc_tr_handle</code>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getInfo</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getInfo(StatusType* status, 
             unsigned itemsLength, 
             const unsigned char* items, 
             unsigned bufferLength, 
             unsigned char* buffer)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_transaction_info()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>prepare</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void prepare(StatusType* status, 
             unsigned msgLength, 
             const unsigned char* message)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_prepare_transaction2()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>commit</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void commit(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_commit_transaction()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>commitRetaining</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void commitRetaining(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_commit_retaining()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>rollback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void rollback(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_rollback_transaction()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>rollbackRetaining</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void rollbackRetaining(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_rollback_retaining()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>disconnect</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void disconnect(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>fb_disconnect_transaction()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>join</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* join(StatusType* status, ITransaction* transaction) 
]]>
</programlisting>
                            </para>
                            <para>соединяет текущую транзакцию и транзакцию переданную как параметр
                                в единую распределённую транзакцию (с использованием Dtc). При
                                успешном выполнении текущая транзакция и транзакция переданная в
                                качестве параметра освобождаются и больше не должны
                                использоваться.</para>
                        </listitem>
                        <listitem>
                            <para>validate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* validate(StatusType* status, IAttachment* attachment)
]]>
</programlisting>
                            </para>
                            <para>этот метод используется для поддержки координатора распределенных
                                транзакций.</para>
                        </listitem>
                        <listitem>
                            <para>enterDtc</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ITransaction* enterDtc(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>этот метод используется для поддержки координатора распределенных
                                транзакций.</para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iversioncallback">
                <info>
                    <title>IVersionCallback</title>
                    <keywordset>
                        <keyword>IVersionCallback</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IVersionCallback</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IVersionCallback</interfacename> — обратный вызов
                        для <methodname>IUtil::getFbVersion()</methodname>.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>callback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void callback(StatusType* status, const char* text)
]]>
</programlisting>
                            </para>
                            <para>вызывается движком firebird для каждой строки в многострочной
                                версии отчета. Позволяет печатать эти строки одна за другой,
                                помещать их в поле сообщения в любом графическом интерфейсе и т. д. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iutil">
                <info>
                    <title>IUtil</title>
                    <keywordset>
                        <keyword>IUtil</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IUtil</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IUtil</interfacename> — различные вспомогательные
                        методы, требуемые здесь или там.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getFbVersion</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getFbVersion(StatusType* status, 
                  IAttachment* att, 
                  IVersionCallback* callback)
]]>
</programlisting>
                            </para>
                            <para>производят длинный и красивый отчет о версии для firebird. Это
                                можно увидеть в <application>ISQL</application> при вызове с ключом
                                    <code>-Z</code>. </para>
                        </listitem>
                        <listitem>
                            <para>loadBlob</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void loadBlob(StatusType* status, 
              ISC_QUAD* blobId, 
              IAttachment* att, 
              ITransaction* tra, 
              const char* file, 
              FB_BOOLEAN txt)
]]>
</programlisting>
                            </para>
                            <para>загрузка BLOB из файла. </para>
                        </listitem>
                        <listitem>
                            <para>dumpBlob</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void dumpBlob(StatusType* status, 
              ISC_QUAD* blobId, 
              IAttachment* att, 
              ITransaction* tra, 
              const char* file, 
              FB_BOOLEAN txt)
]]>
</programlisting>
                            </para>
                            <para>сохраняет BLOB в файл. </para>
                        </listitem>
                        <listitem>
                            <para>getPerfCounters</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void getPerfCounters(StatusType* status, 
                     IAttachment* att, 
                     const char* countersSet, 
                     ISC_INT64* counters) 
]]>
</programlisting>
                            </para>
                            <para>получает статистику для данного подключения. </para>
                        </listitem>
                        <listitem>
                            <para>executeCreateDatabase</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IAttachment* executeCreateDatabase(StatusType* status, 
                                   unsigned stmtLength, 
                                   const char* creatDBstatement, 
                                   unsigned dialect, 
                                   FB_BOOLEAN* stmtIsCreateDb)
]]>
</programlisting>
                            </para>
                            <para>выполняет инструкцию <code>CREATE DATABASE ...</code> — трюк ISC с
                                NULL дескриптором оператора не работает с интерфейсами. </para>
                        </listitem>
                        <listitem>
                            <para>decodeDate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void decodeDate(ISC_DATE date, 
                unsigned* year, 
                unsigned* month, 
                unsigned* day)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_decode_sql_date()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>decodeTime</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void decodeTime(ISC_TIME time, 
                unsigned* hours, 
                unsigned* minutes, 
                unsigned* seconds, 
                unsigned* fractions)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_decode_sql_time()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>encodeDate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ISC_DATE encodeDate(unsigned year, unsigned month, unsigned day)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_encode_sql_date()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>encodeTime</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ISC_TIME encodeTime(unsigned hours, 
                    unsigned minutes, 
                    unsigned seconds, 
                    unsigned fractions)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>isc_encode_sql_time()</code>. </para>
                        </listitem>
                        <listitem>
                            <para>formatStatus</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned formatStatus(char* buffer, unsigned bufferSize, IStatus* status)
]]>
</programlisting>
                            </para>
                            <para>заменяет <code>fb_interpret()</code>. Размер буфера, переданного в
                                этот метод, не должен быть меньше 50 байт. </para>
                        </listitem>
                        <listitem>
                            <para>getClientVersion</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getClientVersion()
]]>
</programlisting>
                            </para>
                            <para>возвращает целое число, содержащее основную версию в байте 0 и
                                младшую версию в байте 1. </para>
                        </listitem>
                        <listitem>
                            <para>getXpbBuilder</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IXpbBuilder* getXpbBuilder(StatusType* status, 
                           unsigned kind, 
                           const unsigned char* buf, 
                           unsigned len)
]]>
</programlisting>
                            </para>
                            <para>возвращает интерфейс <link linkend="fbapi-interfaces-ixpbbuilder"
                                    >IXpbBuilder</link>. Допустимые <replaceable>kind</replaceable>
                                перечислены в <interfacename>IXpbBuilder</interfacename>. </para>
                        </listitem>
                        <listitem>
                            <para>setOffsets</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned setOffsets(StatusType* status, 
                    IMessageMetadata* metadata, 
                    IOffsetsCallback* callback)
]]>
</programlisting>
                            </para>
                            <para>устанавливает допустимые смещения в <link
                                    linkend="fbapi-interfaces-imessagemetadata"
                                    >IMessageMetadata</link>. Выполняет вызовы для обратного вызова
                                в <link linkend="fbapi-interfaces-ioffsetscallback"
                                    >IOffsetsCallback</link> для каждого поля/параметра. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-ixpbbuilder">
                <info>
                    <title>IXpbBuilder</title>
                    <keywordset>
                        <keyword>IXpbBuilder</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IXpbBuilder</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IXpbBuilder</interfacename></para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>clear</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void clear(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>сбрасывает построитель в пустое состояние. </para>
                        </listitem>
                        <listitem>
                            <para>removeCurrent</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void removeCurrent(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>удаляет текущий clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>insertInt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void insertInt(StatusType* status, unsigned char tag, int value)
]]>
</programlisting>
                            </para>
                            <para>вставляет clumplet со значением, представляющим целое число в
                                сетевом формате. </para>
                        </listitem>
                        <listitem>
                            <para>insertBigInt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void insertBigInt(StatusType* status, unsigned char tag, ISC_INT64 value) 
]]>
</programlisting>
                            </para>
                            <para>вставляет clumplet со значением, представляющим 64-битное целое
                                число в сетевом формате. </para>
                        </listitem>
                        <listitem>
                            <para>insertBytes</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void insertBytes(StatusType* status, unsigned char tag, const void* bytes, unsigned length)
]]>
</programlisting>
                            </para>
                            <para>вставляет clumplet со значением, содержащим переданные байты.
                            </para>
                        </listitem>
                        <listitem>
                            <para>insertTag</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void insertTag(StatusType* status, unsigned char tag)
]]>
</programlisting>
                            </para>
                            <para>вставляет clumplet без значения. </para>
                        </listitem>
                        <listitem>
                            <para>isEof</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN isEof(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>проверяет, нет ли текущего clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>moveNext</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void moveNext(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>переходит к следующему clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>rewind</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void rewind(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>переходит к первому clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>findFirst</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN findFirst(StatusType* status, unsigned char tag)
]]>
</programlisting>
                            </para>
                            <para>находит первый clumplet с данным тегом. </para>
                        </listitem>
                        <listitem>
                            <para>findNext</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN findNext(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>находит следующий clumplet с заданным тегом. </para>
                        </listitem>
                        <listitem>
                            <para>getTag</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned char getTag(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>возвращает тег для текущего clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>getLength</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getLength(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>возвращает длину текущего значения clumplet. </para>
                        </listitem>
                        <listitem>
                            <para>getInt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int getInt(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение текущего clumplet как целое. </para>
                        </listitem>
                        <listitem>
                            <para>getBigInt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
SC_INT64 getBigInt(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение текущего clumplet как 64-битное целое число.
                            </para>
                        </listitem>
                        <listitem>
                            <para>getString</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getString(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение текущего clumplet как указатель на
                                нуль-терминальную строку (указатель действителен до следующего
                                вызова этого метода). </para>
                        </listitem>
                        <listitem>
                            <para>getBytes</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const unsigned char* getBytes(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает значение текущего clumplet как указатель на unsigned
                                char. </para>
                        </listitem>
                        <listitem>
                            <para>getBufferLength</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned getBufferLength(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает длину блока параметров. </para>
                        </listitem>
                        <listitem>
                            <para>getBuffer</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const unsigned char* getBuffer(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает указатель на блок параметров. </para>
                        </listitem>
                    </orderedlist>
                </para>
                <section>
                    <title>Константы, определенные интерфейсом IXpbBuilder</title>
                    <para>Допустимые типы построителей: <itemizedlist spacing="compact">
                            <listitem>
                                <para><code>DPB</code></para>
                            </listitem>
                            <listitem>
                                <para><code>SPB_ATTACH</code></para>
                            </listitem>
                            <listitem>
                                <para><code>SPB_START</code></para>
                            </listitem>
                            <listitem>
                                <para><code>TPB</code></para>
                            </listitem>
                        </itemizedlist></para>
                </section>
            </section>
        </section>
        <section>
            <title>Плагин шифрования данных передаваемых по сети</title>
            <para>Алгоритмы, выполняющие шифрование данных для разных целей, хорошо известны на
                протяжении многих лет. Единственной "маленькой" типичной проблемой остается то, где
                можно получить секретный ключ, который будет использоваться этим алгоритмом. К
                счастью для шифрования сетевого трафика есть одно хорошее решение — уникальный ключ
                шифрования должен быть сгенерирован плагином аутентификации. По крайней мере, по
                умолчанию плагин SRP может создать такой ключ. Этот ключ устойчив к атакам, в том
                числе с помощью "человека в середине" (man-in-the-middle). Поэтому для плагина
                шифрования сетевого трафика был выбран следующий способ предоставления ключей:
                получать его от плагина проверки подлинности (аутентификации). (В случае, если
                используемый плагин аутентификации не может предоставить ключ, псевдоплагин может
                быть добавлен в списки AuthClient и AuthServer для создания ключей, что-то вроде
                двух асимметричных пар приватного и публичного.)</para>
            <section xml:id="fbapi-interfaces-icryptkey">
                <info>
                    <title>ICryptKey</title>
                    <keywordset>
                        <keyword>ICryptKey</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>ICryptKey</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ICryptKey</interfacename> используется для
                        хранения ключа, предоставленного плагином аутентификации, и передает его в
                        плагин шифрования сетевого трафика. Этот интерфейс следует использовать
                        следующим образом: когда плагин аутентификации сервера или клиента готов
                        предоставить ключ, то он запрашивает <link
                            linkend="fbapi-interfaces-iserverblock">IServerBlock</link> или <link
                            linkend="fbapi-interfaces-iclientblock">IClientBlock</link> для создания
                        нового интерфейса <interfacename>ICryptKey</interfacename> и хранит в нем
                        ключ. Подходящий для <link linkend="fbapi-interfaces-iwirecryptplugin"
                            >IWireCryptPlugin</link> тип ключа будет выбран Firebird и передан этому
                        интерфейсу.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>setSymmetric</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setSymmetric(StatusType* status, 
                  const char* type, 
                  unsigned keyLength, 
                  const void* key)
]]>
</programlisting>
                            </para>
                            <para>сохраняет симметричный ключ заданного типа. </para>
                        </listitem>
                        <listitem>
                            <para>setAsymmetric</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setAsymmetric(StatusType* status, 
                   const char* type, 
                   unsigned encryptKeyLength, 
                   const void* encryptKey, 
                   unsigned decryptKeyLength, 
                   const void* decryptKey)
]]>
</programlisting>
                            </para>
                            <para>сохраняет пару асимметричных ключей заданного типа. </para>
                        </listitem>
                        <listitem>
                            <para>getEncryptKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const void* getEncryptKey(unsigned* length) 
]]>
</programlisting>
                            </para>
                            <para>возвращает ключ для шифрования. </para>
                        </listitem>
                        <listitem>
                            <para>getDecryptKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const void* getDecryptKey(unsigned* length)) 
]]>
</programlisting>
                            </para>
                            <para>возвращает ключ для дешифрирования (в случае симметричного ключа
                                получается тот же результат, что и
                                    <methodname>getEncryptKey()</methodname>). </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iwirecryptplugin">
                <info>
                    <title>IWireCryptPlugin</title>
                    <keywordset>
                        <keyword>IWireCryptPlugin</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IWireCryptPlugin</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IWireCryptPlugin</interfacename> является
                        основным интерфейсом плагина сетевого шифрования. Как и любой другой такой
                        интерфейс, он должен быть реализован автором плагина.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getKnownTypes</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getKnownTypes(StatusType* status) 
]]>
</programlisting>
                            </para>
                            <para>возвращает список допустимых ключей, разделённых
                                пробелами/табуляциями/запятыми. </para>
                        </listitem>
                        <listitem>
                            <para>setKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setKey(StatusType* status, ICryptKey* key) 
]]>
</programlisting>
                            </para>
                            <para>плагин должен использовать ключ, переданный ему этим вызовом.
                            </para>
                        </listitem>
                        <listitem>
                            <para>encrypt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void encrypt(StatusType* status, 
             unsigned length, 
             const void* from, 
             void* to)
]]>
</programlisting>
                            </para>
                            <para>шифрует пакет, который должен быть отправлен по сети. </para>
                        </listitem>
                        <listitem>
                            <para>decrypt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void decrypt(StatusType* status, 
             unsigned length, 
             const void* from, 
             void* to)
]]>
</programlisting>
                            </para>
                            <para>расшифровывает пакет, полученный из сети. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
        </section>
        <section>
            <title>Плагин аутентификации на серверной стороне</title>
            <para>Плагин аутентификации содержит две требуемые части — клиентскую и серверную, а
                также может содержать связанную с ним третью часть — менеджер пользователей. В
                процессе аутентификации клиент Firebird вызывает клиентский плагин и отправляет
                сгенерированные им данные на сервер, затем сервер вызывает серверный плагин и
                отправляет сгенерированные им данные клиенту. Этот процесс повторяется до тех пор,
                пока оба плагина возвращают код <code>AUTH_MORE_DATA</code>.
                    <code>AUTH_SUCCESS</code>, возвращенный на стороне сервера, означает успешную
                аутентификацию, <code>AUTH_FAILED</code> с любой стороны — немедленное прерывание
                итеративного процесса и отказ, сообщаемый клиенту, <code>AUTH_CONTINUE</code>
                означает, что должен быть проверен следующий плагин из списка настроенных плагинов
                проверки подлинности.</para>
            <para>Нет выделенных примеров плагинов для аутентификации, но в исходных кодах firebird
                в каталоге <filename>src/auth</filename> можно найти плагин <emphasis role="italic"
                    >AuthDbg</emphasis>, с помощью которого можно учиться на тривиальном примере
                (без сложных вычислений как, например, в <emphasis role="italic">Srp</emphasis>, и
                без вызовов сумасшедших функций WinAPI, таких как в <emphasis role="italic"
                    >AuthSspi</emphasis>), как клиентская и серверная сторона выполняют
                аутентификацию (рукопожатие).</para>
            <section xml:id="fbapi-interfaces-iauth">
                <info>
                    <title>IAuth</title>
                    <keywordset>
                        <keyword>IAuth</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IAuth</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IAuth</interfacename> не содержит методов, только
                        некоторые константы, определяющие коды, возвращаются из метода
                            <methodname>authenticate()</methodname> в <link
                            linkend="fbapi-interfaces-iclient">IClient</link> и <link
                            linkend="fbapi-interfaces-iserver">IServer</link>.</para>
                </formalpara>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para><code>AUTH_FAILED</code></para>
                        </listitem>
                        <listitem>
                            <para><code>AUTH_SUCCESS</code></para>
                        </listitem>
                        <listitem>
                            <para><code>AUTH_MORE_DATA</code></para>
                        </listitem>
                        <listitem>
                            <para><code>AUTH_CONTINUE</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iwriter">
                <info>
                    <title>IWriter</title>
                    <keywordset>
                        <keyword>IWriter</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IWriter</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IWriter</interfacename> — записывает блок
                        параметров аутентификации.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>reset</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void reset() 
]]>
</programlisting>
                            </para>
                            <para>очищает целевой блок. </para>
                        </listitem>
                        <listitem>
                            <para>add</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void add(StatusType* status, const char* name) 
]]>
</programlisting>
                            </para>
                            <para>добавляет имя логина. </para>
                        </listitem>
                        <listitem>
                            <para>setType</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setType(StatusType* status, const char* value)
]]>
</programlisting>
                            </para>
                            <para>устанавливает тип добавленного логина (пользователь, роль, группа
                                и т.д.). </para>
                        </listitem>
                        <listitem>
                            <para>setDb</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setDb(StatusType* status, const char* value)  
]]>
</programlisting>
                            </para>
                            <para>устанавливает базу данных безопасности, в которой была выполнена
                                аутентификация. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iserverblock">
                <title>IServerBlock</title>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IServerBlock</interfacename> используется
                        серверной частью модуля аутентификации для обмена данными с клиентом.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getLogin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getLogin()
]]>
</programlisting>
                            </para>
                            <para>возвращает имя пользователя, переданное от клиента. </para>
                        </listitem>
                        <listitem>
                            <para>getData</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const unsigned char* getData(unsigned* length)
]]>
</programlisting>
                            </para>
                            <para>возвращает данные аутентификации, переданные от клиента. </para>
                        </listitem>
                        <listitem>
                            <para>putData</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void putData(StatusType* status, unsigned length, const void* data)
]]>
</programlisting>
                            </para>
                            <para>передаёт данные аутентификации клиенту. </para>
                        </listitem>
                        <listitem>
                            <para>newKey</para>
                            <para><programlisting language="cpp">
<![CDATA[
ICryptKey* newKey(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>создаёт новый ключ шифрования и добавляет его в список доступных
                                для плагинов шифрования сетевого трафика. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            <section xml:id="fbapi-interfaces-iserver">
                <info>
                    <title>IServer</title>
                    <keywordset>
                        <keyword>IServer</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>IServer</primary>
                </indexterm>
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IServer</interfacename> является основным
                        интерфейсом серверной части плагина аутентификации.</para>
                </formalpara>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>authenticate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int authenticate(StatusType* status, 
                 IServerBlock* sBlock, 
                 IWriter* writerInterface)
]]>
</programlisting>
                            </para>
                            <para>выполняет один этап аутентификации. Обмен данными с клиентом
                                осуществляется с использованием интерфейса
                                    <replaceable>sBlock</replaceable>. Когда создается некоторый
                                элемент аутентификации, его следует добавить в блок аутентификации с
                                помощью <replaceable>writerInterface</replaceable>. Возможные
                                значения возврата определяются в интерфейсе <link
                                    linkend="fbapi-interfaces-iauth">IAuth</link>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
        </section>
        
        <section>
            <title>Плагин аутентификации на клиентской стороне</title>
            
            <section xml:id="fbapi-interfaces-iclientblock">
                <info>
                    <title>IClientBlock</title>
                    <keywordset>
                        <keyword>IClientBlock</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IClientBlock</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IClientBlock</interfacename> используется
                        клиентской стороной модуля аутентификации для обмена данными с
                        сервером.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getLogin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getLogin() 
]]>
</programlisting>
                            </para>
                            <para>возвращает имя пользователя, если оно присутствует в DPB. </para>
                        </listitem>
                        <listitem>
                            <para>getPassword</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getPassword()
]]>
</programlisting>
                            </para>
                            <para>возвращает пароль, если он присутствует в DPB. </para>
                        </listitem>
                        <listitem>
                            <para>getData</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const unsigned char* getData(unsigned* length)
]]>
</programlisting>
                            </para>
                            <para>возвращает данные аутентификации, переданные с сервера. </para>
                        </listitem>
                        <listitem>
                            <para>putData</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void putData(StatusType* status, unsigned length, const void* data)
]]>
</programlisting>
                            </para>
                            <para>передаёт данные аутентификации на сервер. </para>
                        </listitem>
                        <listitem>
                            <para>newKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICryptKey* newKey(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>создаёт новый ключ шифрования и добавляет его в список доступных
                                для плагинов шифрования сетевого трафика. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            
            <section xml:id="fbapi-interfaces-iclient">
                <info>
                    <title>IClient</title>
                    <keywordset>
                        <keyword>IClient</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IClient</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IClient</interfacename> является основным
                        интерфейсом клиентской стороны модуля аутентификации. </para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>authenticate</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int authenticate(StatusType* status, 
                 IClientBlock* cBlock)
]]>
</programlisting>
                            </para>
                            <para>выполняет один этап аутентификации. Обмен данными с сервером
                                осуществляется с использованием интерфейса
                                    <replaceable>cBlock</replaceable>. Возможные значения возврата
                                определяются в интерфейсе <interfacename>IAuth</interfacename>.
                                    <code>AUTH_SUCCESS</code> обрабатывается клиентской стороной как
                                    <code>AUTH_MORE_DATA</code> (т.е. клиент отправляет
                                сгенерированные данные на сервер и ждет ответа от него). </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
        </section>
        
        <section>
            <title>Плагин управления пользователями</title>
            <para>Этот плагин активно связан с серверной частью проверки подлинности — он
                подготавливает список пользователей для плагина аутентификации. Для каждого плагина
                проверки подлинности требуется менеджер пользователей — некоторые из них могут
                получить доступ к списку пользователей, созданных с использованием не Firebird
                программного обеспечения (например, <emphasis role="italic">AuthSspi</emphasis>).
                Запись, описывающая пользователя, состоит из нескольких полей, и поддерживать
                выполнение нескольких операций, таких как добавление пользователя, изменение
                пользователя, получение списка пользователей и т. д. Плагин должен уметь
                интерпретировать команды, полученные в интерфейсе <link
                    linkend="fbapi-interfaces-iuser">IUser</link>.</para>
            
            <section xml:id="fbapi-interfaces-iuserfield">
                <info>
                    <title>IUserField</title>
                    <keywordset>
                        <keyword>IUserField</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IUserField</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IUserField</interfacename> не используется как
                        автономный интерфейс, он является базовым для
                            <interfacename>ICharUserField</interfacename> и
                            <interfacename>IIntUserField</interfacename>. </para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>entered</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int entered()
]]>
</programlisting>
                            </para>
                            <para>возвращает ненулевое значение, если было введено (присвоено)
                                значение для поля. </para>
                        </listitem>
                        <listitem>
                            <para>specified</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int specified()
]]>
</programlisting>
                            </para>
                            <para>возвращает ненулевое значение, если для поля было присвоено
                                значение NULL. </para>
                        </listitem>
                        <listitem>
                            <para>setEntered</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setEntered(StatusType* status, int newValue)
]]>
</programlisting>
                            </para>
                            <para>устанавливает entered флаг в 0 или ненулевое значение для поля.
                                Нет способа назначить NULL для поля, потому что он никогда не
                                требуется. NULL, если они используются, назначаются реализациями
                                интерфейсами и, следовательно, имеют полный доступ к их внутренним
                                элементам. </para>
                        </listitem>
                    </orderedlist>
                </para>              
            </section>
            
            <section xml:id="fbapi-interfaces-icharuserfield">
                <info>
                    <title>ICharUserField</title>
                    <keywordset>
                        <keyword>ICharUserField</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>ICharUserField</primary>
                </indexterm>
                
                <para>Интерфейс <interfacename>ICharUserField</interfacename>: <orderedlist>
                        <listitem>
                            <para>get</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* get()
]]>
</programlisting>
                            </para>
                            <para>возвращает значение поля как C-строку (\0 терминальную). </para>
                        </listitem>
                        <listitem>
                            <para>set</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void set(StatusType* status, const char* newValue)
]]>
</programlisting>
                            </para>
                            <para>присваивает значение полю. Устанавливает флаг entered в true.
                            </para>
                        </listitem>
                    </orderedlist></para>
            </section>
            
            <section xml:id="fbapi-interfaces-iintuserfield">
                <info>
                    <title>IIntUserField</title>
                    <keywordset>
                        <keyword>IIntUserField</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IIntUserField</primary>
                </indexterm>
                
                <para>Интрефейс <interfacename>IIntUserField</interfacename>: <orderedlist>
                        <listitem>
                            <para>get</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int get()
]]>
</programlisting>
                            </para>
                            <para>возвращает значение поля. </para>
                        </listitem>
                        <listitem>
                            <para>set</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void set(StatusType* status, int newValue)
]]>
</programlisting>
                            </para>
                            <para>присваивает значение полю. Устанавливает флаг entered в true.
                            </para>
                        </listitem>
                    </orderedlist></para>
            </section>
            
            <section xml:id="fbapi-interfaces-iuser">
                <info>
                    <title>IUser</title>
                    <keywordset>
                        <keyword>IUser</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IUser</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IUser</interfacename> — это список методов
                        доступа к полям, включенным в запись о пользователе.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>operation</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned operation() 
]]>
</programlisting>
                            </para>
                            <para>код операции (см. список ниже). </para>
                        </listitem>
                        <listitem>
                            <para>userName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* userName()
]]>
</programlisting>
                            </para>
                            <para>имя пользователя. </para>
                        </listitem>
                        <listitem>
                            <para>password</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* password()
]]>
</programlisting>
                            </para>
                            <para>пароль. </para>
                        </listitem>
                        <listitem>
                            <para>firstName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* firstName()
]]>
</programlisting>
                            </para>
                            <para>это и 2 следующие компоненты полного имени пользователя. </para>
                        </listitem>
                        <listitem>
                            <para>lastName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* lastName()
]]>
</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>middleName</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* middleName()
]]>
</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>comment</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* comment() 
]]>
</programlisting>
                            </para>
                            <para>комментарий (из SQL оператора COMMENT ON USER IS …). </para>
                        </listitem>
                        <listitem>
                            <para>attributes</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICharUserField* attributes() 
]]>
</programlisting>
                            </para>
                            <para>теги в форме <code>tag1=val1, tag2=val2, …, tagN=valN</code>. Val
                                может быть пустым, что означает, что тег будет удален. </para>
                        </listitem>
                        <listitem>
                            <para>active</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IIntUserField* active() 
]]>
</programlisting>
                            </para>
                            <para>изменяет настройку ACTIVE/INACTIVE для пользователя. </para>
                        </listitem>
                        <listitem>
                            <para>admin</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
IIntUserField* admin()
]]>
</programlisting>
                            </para>
                            <para>устанавливает/отменяет права администратора для пользователя.
                            </para>
                        </listitem>
                        <listitem>
                            <para>clear</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void clear(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>устанавливает, что все поля не введены и не указаны. </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>Константы, определенные пользовательским интерфейсом — действующие коды
                    операций. <itemizedlist>
                        <listitem>
                            <para><code>OP_USER_ADD</code> — добавление пользователя.</para>
                        </listitem>
                        <listitem>
                            <para><code>OP_USER_MODIFY</code> — редактирование пользователя.</para>
                        </listitem>
                        <listitem>
                            <para><code>OP_USER_DELETE</code> — удаление пользователя.</para>
                        </listitem>
                        <listitem>
                            <para><code>OP_USER_DISPLAY</code> — отображение пользователя.</para>
                        </listitem>
                        <listitem>
                            <para><code>OP_USER_SET_MAP</code> — включение отображения
                                администраторов Windows на роль <code>RDB$ADMIN</code>.</para>
                        </listitem>
                        <listitem>
                            <para><code>OP_USER_DROP_MAP</code> — выключение отображения
                                администраторов Windows на роль <code>RDB$ADMIN</code>.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            
            <section xml:id="fbapi-interfaces-ilistuser">
                <info>
                    <title>IListUsers</title>
                    <keywordset>
                        <keyword>IListUsers</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IListUsers</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IListUsers</interfacename> — это обратный вызов,
                        используемый плагином проверки подлинности при запросе списка пользователей.
                        Плагин заполняет интерфейс <link linkend="fbapi-interfaces-iuser"
                            >IUser</link> для всех элементов в списке пользователей один за другим и
                        для каждого пользователя вызывает метод <methodname>list()</methodname>
                        этого интерфейса.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>list</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void list(StatusType* status, IUser* user)
]]>
</programlisting>
                            </para>
                            <para>функция обратного вызова. Реализация может делать с полученными
                                данными то что хочет. Например, она может поместить данные из
                                пользовательского параметра в выходной поток сервиса или разместить
                                в специальных таблицах SEC$ группы. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            
            <section xml:id="fbapi-interfaces-ilogoninfo">
                <info>
                    <title>ILogonInfo</title>
                    <keywordset>
                        <keyword>ILogonInfo</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>ILogonInfo</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ILogonInfo</interfacename> содержит данные,
                        переданные плагину управления пользователями для подключения к базе данных
                        безопасности с действительными учётными данными.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>name</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* name()
]]>
</programlisting>
                            </para>
                            <para>возвращает имя пользователя текущего подключения. </para>
                        </listitem>
                        <listitem>
                            <para>role</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* role() 
]]>
</programlisting>
                            </para>
                            <para>возвращает активную роль текущего подключения. </para>
                        </listitem>
                        <listitem>
                            <para>networkProtocol</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* networkProtocol()
]]>
</programlisting>
                            </para>
                            <para>возвращает сетевой протокол текущего подключения. В настоящее
                                время не используется плагинами. </para>
                        </listitem>
                        <listitem>
                            <para>remoteAddress</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* remoteAddress()
]]>
</programlisting>
                            </para>
                            <para>возвращает удаленный адрес текущего подключения. В настоящее время
                                не используется плагинами. </para>
                        </listitem>
                        <listitem>
                            <para>authBlock</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const unsigned char* authBlock(unsigned* length)
]]>
</programlisting>
                            </para>
                            <para>возвращает блок аутентификации текущего подключения. Если не NULL
                                переписывает имя пользователя. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            
            <section xml:id="fbapi-interfaces-imanagement">
                
                <info>
                    <title>IManagement</title>
                    <keywordset>
                        <keyword>IManagement</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IManagement</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IManagement</interfacename> является основным
                        интерфейсом плагина управления пользователями.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>start</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void start(StatusType* status, ILogonInfo* logonInfo)
]]>
</programlisting>
                            </para>
                            <para>запускает плагин, при необходимости он подключается к базе данных
                                безопасности для управления пользователями (использовать это или нет
                                это решение, зависящее от плагинов), используя учетные данные из
                                    <replaceable>logonInfo</replaceable>. </para>
                        </listitem>
                        <listitem>
                            <para>execute</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int execute(StatusType* status, IUser* user, IListUsers* callback)
]]>
</programlisting>
                            </para>
                            <para>выполняет команду, предоставляемую методом
                                    <methodname>operation()</methodname> параметра
                                    <replaceable>user</replaceable>. При необходимости будет
                                использоваться интерфейс обратного вызова. Параметр
                                    <replaceable>callback</replaceable> может иметь значение NULL
                                для команд, не требующих получения списка пользователей. </para>
                        </listitem>
                        <listitem>
                            <para>commit</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void commit(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>подтверждает изменения, выполненные вызовами метода
                                    <methodname>execute()</methodname>. </para>
                        </listitem>
                        <listitem>
                            <para>rollback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void rollback(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>отменяет изменения, выполненные вызовами метода
                                    <methodname>execute()</methodname>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>          
        </section>
        
        <section>
            <title>Плагин шифрования базы данных</title>
            
            <para>Возможность шифрования базы данных присутствовала в Firebird со времён Interbase,
                но соответствующие места в коде были закомментированы. Реализация была сомнительной
                — ключ шифрования всегда отправлялся от клиента в DPB, не было сделано попыток
                скрыть его от внешнего мира, и не предлагалось путей для шифрования существующих баз
                данных. Firebird 3.0 решает большинство проблем, за исключением, вероятно, худшей —
                как управлять ключами шифрования. Мы предлагаем различные типы решений, но они
                требует усилий в плагинах, т. е. нет красивого способа работы с ключами как,
                например, для плагинов шифрования сетевого трафика.</para>
            <para>Перед запуском с собственным плагином шифрования базы данных следует принять во
                внимание следующее. Мы видим два основных случая для которых используется шифрование
                базы данных — во-первых, может потребоваться избежать утечки данных, если сервер
                базы данных физически украден, а во-вторых, оно может использоваться для защиты
                данных в базе данных, которые распространяется вместе со специальным приложением,
                обращающимся к этим данным. Требования к этим случаям совершенно разные. В первом
                случае мы можем доверять серверу базы данных, что он не модифицирован, чтобы красть
                ключи, переданные в плагин безопасности, то есть мы ожидаем, что этот ключ не будет
                отправлен на неподходящий сервер. Во втором случае сервер может быть каким-то
                образом модифицирован для кражи ключей (если они передаются из приложения в плагин
                через код сервера) или даже данных (в качестве последнего места для снятия дампов из
                кэша, где они находятся в не зашифрованном виде). Поэтому ваш плагин должен
                убедиться, что он работает с не измененными двоичными файлами Firebird и вашим
                приложением перед отправкой ключа в плагин, например, плагин может потребоваться от
                них какой-то цифровой подписи. Кроме того, если используется сетевой доступ к
                серверу, то хорошей идеей является проверка того, что сетевой канал зашифрован
                (разбор вывода <code>IUtil::getFbVersion()</code>) или используется собственный ключ
                шифрования. Вся эта работа должна выполняться в плагине (и в приложении, работающим
                с ним), то есть алгоритм шифрования блока базы данных сам по себе может оказаться
                наиболее простой частью плагина шифрования базы данных, особенно когда для него
                используется некоторая стандартная библиотека.</para>
            
            <section xml:id="fbapi-interfaces-icryptkeycallback">
                
                <info>
                    <title>ICryptKeyCallback</title>
                    <keywordset>
                        <keyword>ICryptKeyCallback</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>ICryptKeyCallback</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>ICryptKeyCallback</interfacename> должен
                        обеспечивать передачу ключа шифрования в плагин шифрования базы данных или
                        плагин хранителя ключа.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>callback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
unsigned callback(unsigned dataLength, 
                  const void* data, 
                  unsigned bufferLength, 
                  void* buffer)
]]>
</programlisting>
                            </para>
                            <para>при выполнении обратного вызова информация передается в обоих
                                направлениях. Источник ключа получает
                                    <replaceable>dataLength</replaceable> байт данных и может
                                отправлять <replaceable>bufferLength</replaceable> байт в буфер.
                                Возвращает фактическое количество байтов, помещенных в буфер.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            
            <section xml:id="fbapi-interfaces-idbcryptinfo">
                <info>
                    <title>IDbCryptInfo</title>
                    <keywordset>
                        <keyword>IDbCryptInfo</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IDbCryptInfo</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IDbCryptInfo</interfacename> передается движку
                            <interfacename>IDbCryptPlugin</interfacename>. Плагин может сохранить
                        этот интерфейс и использовать, когда это необходимо, для получения
                        дополнительной информации о базе данных.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>getDatabaseFullPath</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
const char* getDatabaseFullPath(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>возвращает полное (включая путь) имя первичного файла базы данных.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
            
            <section xml:id="fbapi-interfaces-idbcryptplugin">
                <info>
                    <title>IDbCryptPlugin</title>
                    <keywordset>
                        <keyword>IDbCryptPlugin</keyword>
                    </keywordset>
                </info>
                
                <indexterm>
                    <primary>IDbCryptPlugin</primary>
                </indexterm>
                
                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IDbCryptPlugin</interfacename> является основным
                        интерфейсом плагина шифрования базы данных.</para>
                </formalpara>
                
                <para>
                    <orderedlist>
                        <listitem>
                            <para>setKey</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setKey(StatusType* status, 
            unsigned length, 
            IKeyHolderPlugin** sources, 
            const char* keyName)
]]>
</programlisting>
                            </para>
                            <para>используется для предоставления информации плагину шифрования базы
                                данных о ключе шифрования. Firebird никогда не передает ключи для
                                этого типа плагина напрямую. Вместо этого массив <link
                                    linkend="fbapi-interfaces-ikeyholderplugin"
                                    >IKeyHolderPlugins</link> заданной длины передается в плагин
                                шифрования, который должен получить от одного из них интерфейс <link
                                    linkend="fbapi-interfaces-icryptkeycallback"
                                    >ICryptKeyCallback</link> и затем получить ключ, используя его.
                                Параметр <replaceable>keyName</replaceable> — это имя ключа, которое
                                было введено в операторе <code>ALTER DATABASE ENCRYPT ...</code>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>encrypt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void encrypt(StatusType* status, 
             unsigned length, 
             const void* from, 
             void* to)
]]>
</programlisting>
                            </para>
                            <para>шифрует данные перед записью блока в файл базы данных </para>
                        </listitem>
                        <listitem>
                            <para>decrypt</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void decrypt(StatusType* status, 
             unsigned length, 
             const void* from, 
             void* to)
]]>
</programlisting>
                            </para>
                            <para>расшифровывает данные после чтения блока из файла базы данных.
                            </para>
                        </listitem>
                        <listitem>
                            <para>setInfo</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
void setInfo(StatusType* status, 
             IDbCryptInfo* info)
]]>
</programlisting>
                            </para>
                            <para>в этом методе плагин шифрования обычно сохраняет информационный
                                интерфейс для будущего использования. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
        </section>
        
        <section>
            <title>Хранитель ключа для плагина шифрования базы данных</title>
            
            <para>Этот тип плагина необходим для разграничения функциональности — плагин шифрования
                базы данных имеет дело с фактическим шифрованием, держатель ключа решает вопросы,
                связанные с предоставлением ему ключа безопасным способом. Плагин может получить
                ключ из приложения или загрузить его каким-либо другим способом (вплоть до
                использования флэш-устройства, вставленного в сервер при запуске Firebird).</para>

            <section xml:id="fbapi-interfaces-ikeyholderplugin">
                <info>
                    <title>IKeyHolderPlugin</title>
                    <keywordset>
                        <keyword>IKeyHolderPlugin</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>IKeyHolderPlugin</primary>
                </indexterm>

                <formalpara>
                    <title>Назначение:</title>
                    <para>Интерфейс <interfacename>IKeyHolderPlugin</interfacename> является
                        основным интерфейсом для плагина хранения ключей шифрования.</para>
                </formalpara>

                <para>
                    <orderedlist>
                        <listitem>
                            <para>keyCallback</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
int keyCallback(StatusType* status, 
                ICryptKeyCallback* callback)
]]>
</programlisting>
                            </para>
                            <para>используется для передачи интерфейса <link
                                    linkend="fbapi-interfaces-icryptkeycallback"
                                    >ICryptKeyCallback</link> в подключение (если он предоставляется
                                пользователем с вызовом
                                    <methodname>IProvider::setDbCryptCallback()</methodname>). Этот
                                вызов всегда выполняется в момент подключения к базе данных, и
                                некоторые держатели ключа могут отклонить подключение, если не был
                                предоставлен удовлетворительный ключ. </para>
                        </listitem>
                        <listitem>
                            <para>keyHandle</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICryptKeyCallback* keyHandle(StatusType* status, 
                             const char* keyName)
]]>
</programlisting>
                            </para>
                            <para>предназначен для непосредственного вызова интерфейсом <link
                                    linkend="fbapi-interfaces-idbcryptplugin">IDbCryptPlugin</link>
                                для получения интерфейса обратного вызова для именованного ключа из
                                держателя ключа. Это позволяет использовать код Firebird с открытым
                                исходным кодом так, чтобы никогда не касаться фактических ключей,
                                избегая возможности кражи ключа, изменяющим код Firebird. После
                                получения интерфейса <link
                                    linkend="fbapi-interfaces-icryptkeycallback"
                                    >ICryptKeyCallback</link> плагин шифрования запускает обмен
                                данными, используя его. Держатель ключа может (например) проверить
                                цифровую подпись плагина шифрования перед отправкой ему ключа, чтобы
                                избежать использования модифицированного плагина шифрования,
                                способного украсть секретный ключ. </para>
                        </listitem>
                        <listitem>
                            <para>useOnlyOwnKeys</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
FB_BOOLEAN useOnlyOwnKeys(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>информирует Firebird о том, будет ли использоваться ключ,
                                предоставленный другим держателем ключа, или нет. Имеет смысл только
                                для SuperServer — только он может делиться ключами шифрования базы
                                данных между подключениями. Возвращая <code>FB_TRUE</code> из этого
                                метода, принудительно заставляет Firebird убедиться, что этот
                                конкретный держатель ключа (и, следовательно, связанное с ним
                                подключение) предоставляет правильный ключ шифрования, прежде чем
                                позволить ему работать с базой данных. </para>
                        </listitem>
                        <listitem>
                            <para>chainHandle</para>
                            <para>
                                <programlisting language="cpp">
<![CDATA[
ICryptKeyCallback* chainHandle(StatusType* status)
]]>
</programlisting>
                            </para>
                            <para>поддержка цепочки держателей ключей. В некоторых случаях ключ
                                должен проходить через более чем один держатель ключа, прежде чем он
                                достигнет плагина шифрования базы данных. Это необходимо (например)
                                для поддержки <code>EXECUTE STATEMENT</code> в зашифрованной базе
                                данных. Это всего лишь пример — цепочки также используются в
                                некоторых других случаях. Интерфейс обратного вызова, возвращенный
                                этим методом, может отличаться от возвращаемого функцией
                                    <methodname>keyHandle()</methodname> (см. выше). Как правило, он
                                должен иметь возможность дублировать ключи один в один, полученные
                                из <interfacename>IKeyHolderPlugin</interfacename> при вызове
                                функции <methodname>keyCallback()</methodname>. </para>
                        </listitem>
                    </orderedlist>
                </para>
            </section>
        </section>
    </section>

    <section xml:id="fbapi-noninterface">
        <title>Не интерфейсные объекты, используемые в API</title>

        <note>
            <para>Они находятся в специальном заголовке <filename>Message.h</filename> C++</para>
        </note>

        <para>Следующие 3 класса используются для представления типов DATE, TIME и TIMESTAMP
            (datetime) при использовании макроса FB_MESSAGE. Члены структуры данных, представляющие
            статическое сообщение, соответствуют полям типов FB_DATE/FB_TIME/ FB_TIMESTAMP, будут
            иметь тип одного из этих классов. Для получения доступа к полям даты и времени в
            статических сообщениях необходимо знать методы и члены класса (которые достаточно само
            описательны, чтобы не описывать их здесь).</para>

        <section xml:id="fbapi-classes-fbdate">
            <info>
                <title>FbDate</title>
                <keywordset>
                    <keyword>FbDate</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>FbDate</primary>
            </indexterm>
            <para>Методы класса <classname>FbDate</classname>: <orderedlist>
                    <listitem>
                        <para>decode</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
void decode(IUtil* util, 
            unsigned* year, 
            unsigned* month, 
            unsigned* day)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getYear</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getYear(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getMonth</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getMonth(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getDay</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getDay(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>encode</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
void encode(IUtil* util, 
            unsigned year, 
            unsigned month, 
            unsigned day)
]]>
</programlisting>
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>

        <section xml:id="fbapi-classes-fbtime">
            <info>
                <title>FbTime</title>
                <keywordset>
                    <keyword>FbTime</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>FbTime</primary>
            </indexterm>
            <para>Методы класса <classname>FbTime</classname>: <orderedlist>
                    <listitem>
                        <para>decode</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
void decode(IUtil* util, 
            unsigned* hours, 
            unsigned* minutes, 
            unsigned* seconds, 
            unsigned* fractions)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getHours</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getHours(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getMinutes</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getMinutes(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getSeconds</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getSeconds(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>getFractions</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
unsigned getFractions(IUtil* util)
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>encode</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
void encode(IUtil* util, 
            unsigned hours, 
            unsigned minutes, 
            unsigned seconds, 
            unsigned fractions)
]]>
</programlisting>
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>

        <section xml:id="fbapi-classes-fbtimestamp">
            <info>
                <title>FbTimestamp</title>
                <keywordset>
                    <keyword>FbTimestamp</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>FbTimestamp</primary>
            </indexterm>
            <para>Члены класса <classname>FbTimestamp </classname>: <orderedlist>
                    <listitem>
                        <para>date</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
FbDate date;
]]>
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>time</para>
                        <para>
                            <programlisting language="cpp">
<![CDATA[
FbTime time;
]]>
</programlisting>
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>

        <section xml:id="fbapi-objects-fbchar">
            <info>
                <title>FbChar и FbVarChar</title>
                <keywordset>
                    <keyword>FbChar</keyword>
                    <keyword>FbVarChar</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>FbChar</primary>
            </indexterm>
            <indexterm>
                <primary>FbVarChar</primary>
            </indexterm>
            <para>Следующие два шаблона используются в статических сообщениях для представления
                полей CHAR(<replaceable>N</replaceable>) и VARCHAR(<replaceable>N</replaceable>). <programlisting language="cpp">
<![CDATA[
template <unsigned N>
struct FbChar
{
    char str[N];
};
]]>            
        </programlisting>
                <programlisting language="cpp">
<![CDATA[
template <unsigned N>
struct FbVarChar
{
    ISC_USHORT length;
    char str[N];
    void set(const char* s);
};
]]>            
        </programlisting>
            </para>
        </section>
    </section>

    <section xml:id="fbapi-conclusion">
        <title>Заключение</title>
        <para>В этом документе отсутствуют два типа плагинов — ExternalEngine и Trace. Информация о
            них будет доступна в следующем выпуске.</para>
    </section>
</chapter>
